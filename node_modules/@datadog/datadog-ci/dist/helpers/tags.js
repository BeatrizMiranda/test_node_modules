"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSpanTags = exports.parseMetrics = exports.parseTags = exports.SERVICE = exports.SPAN_TYPE = exports.GIT_TAG = exports.GIT_SHA = exports.GIT_COMMIT_MESSAGE = exports.GIT_COMMIT_COMMITTER_NAME = exports.GIT_COMMIT_COMMITTER_EMAIL = exports.GIT_COMMIT_COMMITTER_DATE = exports.GIT_COMMIT_AUTHOR_NAME = exports.GIT_COMMIT_AUTHOR_EMAIL = exports.GIT_COMMIT_AUTHOR_DATE = exports.GIT_BRANCH = exports.CI_NODE_LABELS = exports.CI_NODE_NAME = exports.CI_ENV_VARS = exports.CI_BUILD_LEVEL = exports.CI_LEVEL = exports.CI_STAGE_NAME = exports.CI_JOB_NAME = exports.CI_JOB_URL = exports.GIT_REPOSITORY_URL = exports.CI_WORKSPACE_PATH = exports.CI_PIPELINE_NUMBER = exports.CI_PIPELINE_NAME = exports.CI_PIPELINE_ID = exports.CI_PROVIDER_NAME = exports.CI_PIPELINE_URL = void 0;
// Build
const ci_1 = require("./ci");
const format_git_span_data_1 = require("./git/format-git-span-data");
const user_provided_git_1 = require("./user-provided-git");
exports.CI_PIPELINE_URL = 'ci.pipeline.url';
exports.CI_PROVIDER_NAME = 'ci.provider.name';
exports.CI_PIPELINE_ID = 'ci.pipeline.id';
exports.CI_PIPELINE_NAME = 'ci.pipeline.name';
exports.CI_PIPELINE_NUMBER = 'ci.pipeline.number';
exports.CI_WORKSPACE_PATH = 'ci.workspace_path';
exports.GIT_REPOSITORY_URL = 'git.repository_url';
exports.CI_JOB_URL = 'ci.job.url';
exports.CI_JOB_NAME = 'ci.job.name';
exports.CI_STAGE_NAME = 'ci.stage.name';
exports.CI_LEVEL = '_dd.ci.level';
// @deprecated TODO: remove this once backend is updated
exports.CI_BUILD_LEVEL = '_dd.ci.build_level';
exports.CI_ENV_VARS = '_dd.ci.env_vars';
exports.CI_NODE_NAME = 'ci.node.name';
exports.CI_NODE_LABELS = 'ci.node.labels';
// Git
exports.GIT_BRANCH = 'git.branch';
exports.GIT_COMMIT_AUTHOR_DATE = 'git.commit.author.date';
exports.GIT_COMMIT_AUTHOR_EMAIL = 'git.commit.author.email';
exports.GIT_COMMIT_AUTHOR_NAME = 'git.commit.author.name';
exports.GIT_COMMIT_COMMITTER_DATE = 'git.commit.committer.date';
exports.GIT_COMMIT_COMMITTER_EMAIL = 'git.commit.committer.email';
exports.GIT_COMMIT_COMMITTER_NAME = 'git.commit.committer.name';
exports.GIT_COMMIT_MESSAGE = 'git.commit.message';
exports.GIT_SHA = 'git.commit.sha';
exports.GIT_TAG = 'git.tag';
// General
exports.SPAN_TYPE = 'span.type';
exports.SERVICE = 'service';
const parseNumericTag = (numericTag) => {
    if (numericTag) {
        const number = parseFloat(numericTag);
        return isFinite(number) ? number : undefined;
    }
};
/**
 * Receives an array of the form ['key:value', 'key2:value2']
 * and returns an object of the form {key: 'value', key2: 'value2'}
 */
const parseTags = (tags) => {
    try {
        return tags.reduce((acc, keyValuePair) => {
            if (!keyValuePair.includes(':')) {
                return acc;
            }
            const firstColon = keyValuePair.indexOf(':');
            const key = keyValuePair.substring(0, firstColon);
            const value = keyValuePair.substring(firstColon + 1);
            return Object.assign(Object.assign({}, acc), { [key]: value });
        }, {});
    }
    catch (e) {
        return {};
    }
};
exports.parseTags = parseTags;
/**
 * Similar to `parseTags` but it's assumed that numbers are received
 * Receives an array of the form ['key:123', 'key2:321']
 * and returns an object of the form {key: 123, key2: 321}
 */
const parseMetrics = (tags) => {
    try {
        return tags.reduce((acc, keyValuePair) => {
            if (!keyValuePair.includes(':')) {
                return acc;
            }
            const firstColon = keyValuePair.indexOf(':');
            const key = keyValuePair.substring(0, firstColon);
            const value = keyValuePair.substring(firstColon + 1);
            const number = parseNumericTag(value);
            if (number !== undefined) {
                return Object.assign(Object.assign({}, acc), { [key]: number });
            }
            return acc;
        }, {});
    }
    catch (e) {
        return {};
    }
};
exports.parseMetrics = parseMetrics;
/**
 * Get the tags to upload results in CI for the following commands: sarif and sbom.
 * @param config - the configuration of the CLI
 * @param additionalTags - additional tags passed, generally from the command line.
 */
const getSpanTags = (config, additionalTags) => __awaiter(void 0, void 0, void 0, function* () {
    const ciSpanTags = (0, ci_1.getCISpanTags)();
    const gitSpanTags = yield (0, format_git_span_data_1.getGitMetadata)();
    const userGitSpanTags = (0, user_provided_git_1.getUserGitSpanTags)();
    const envVarTags = config.envVarTags ? (0, exports.parseTags)(config.envVarTags.split(',')) : {};
    const cliTags = additionalTags ? (0, exports.parseTags)(additionalTags) : {};
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, gitSpanTags), ciSpanTags), userGitSpanTags), cliTags), envVarTags), (config.env ? { env: config.env } : {}));
});
exports.getSpanTags = getSpanTags;
//# sourceMappingURL=tags.js.map