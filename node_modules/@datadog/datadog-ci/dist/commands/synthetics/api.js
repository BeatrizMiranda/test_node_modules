"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getApiHelper = exports.apiConstructor = exports.is5xxError = exports.isNodeError = exports.isNotFoundError = exports.isForbiddenError = exports.completeMultipartMobileApplicationUpload = exports.formatBackendErrors = exports.EndpointError = void 0;
const querystring_1 = require("querystring");
const utils_1 = require("../../helpers/utils");
const errors_1 = require("./errors");
const run_tests_command_1 = require("./run-tests-command");
const public_1 = require("./utils/public");
const MAX_RETRIES = 3;
const DELAY_BETWEEN_RETRIES = 500; // In ms
const LARGE_DELAY_BETWEEN_RETRIES = 1000; // In ms
class EndpointError extends Error {
    constructor(message, status) {
        super(message);
        this.message = message;
        this.status = status;
        Object.setPrototypeOf(this, EndpointError.prototype);
    }
}
exports.EndpointError = EndpointError;
const formatBackendErrors = (requestError) => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    if ((_b = (_a = requestError.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.errors) {
        const serverHead = `query on ${(_c = requestError.config) === null || _c === void 0 ? void 0 : _c.baseURL}${(_d = requestError.config) === null || _d === void 0 ? void 0 : _d.url} returned:`;
        const errors = requestError.response.data.errors;
        if (errors.length > 1) {
            const formattedErrors = errors.map((message) => `  - ${message}`);
            return `${serverHead}\n${formattedErrors.join('\n')}`;
        }
        else if (errors.length) {
            return `${serverHead} "${errors[0]}"`;
        }
        else {
            return `error querying ${(_e = requestError.config) === null || _e === void 0 ? void 0 : _e.baseURL}${(_f = requestError.config) === null || _f === void 0 ? void 0 : _f.url}`;
        }
    }
    return `could not query ${(_g = requestError.config) === null || _g === void 0 ? void 0 : _g.baseURL}${(_h = requestError.config) === null || _h === void 0 ? void 0 : _h.url}\n${requestError.message}`;
};
exports.formatBackendErrors = formatBackendErrors;
const triggerTests = (request) => (data) => __awaiter(void 0, void 0, void 0, function* () {
    const resp = yield retryRequest({
        data,
        headers: { 'X-Trigger-App': public_1.ciTriggerApp },
        method: 'POST',
        url: '/synthetics/tests/trigger/ci',
    }, request);
    return resp.data;
});
const getTest = (request) => (testId) => __awaiter(void 0, void 0, void 0, function* () {
    const resp = yield retryRequest({
        url: `/synthetics/tests/${testId}`,
    }, request);
    return resp.data;
});
const searchTests = (request) => (query) => __awaiter(void 0, void 0, void 0, function* () {
    const resp = yield retryRequest({
        params: {
            // Search for one more test than limit to detect if too many tests are returned
            count: run_tests_command_1.MAX_TESTS_TO_TRIGGER + 1,
            text: query,
        },
        url: '/synthetics/tests/search',
    }, request);
    return resp.data;
});
const getSyntheticsOrgSettings = (request) => () => __awaiter(void 0, void 0, void 0, function* () {
    const resp = yield retryRequest({
        url: '/synthetics/settings',
    }, request);
    return resp.data;
});
const getBatch = (request) => (batchId) => __awaiter(void 0, void 0, void 0, function* () {
    const resp = yield retryRequest({ url: `/synthetics/ci/batch/${batchId}` }, request, retryOn5xxOr404Errors);
    const serverBatch = resp.data.data;
    return {
        results: serverBatch.results.filter((r) => r.status !== 'skipped' || r.selective_rerun),
        status: serverBatch.status,
    };
});
const pollResults = (request) => (resultIds) => __awaiter(void 0, void 0, void 0, function* () {
    const resp = yield retryRequest({
        params: {
            result_ids: JSON.stringify(resultIds),
        },
        url: '/synthetics/tests/poll_results',
    }, request, retryOn5xxOr404Errors);
    return resp.data.results;
});
const getTunnelPresignedURL = (request) => (testIds) => __awaiter(void 0, void 0, void 0, function* () {
    const resp = yield retryRequest({
        params: {
            test_id: testIds,
        },
        paramsSerializer: (params) => (0, querystring_1.stringify)(params),
        url: '/synthetics/ci/tunnel',
    }, request);
    return resp.data;
});
const getMobileApplicationPresignedURLs = (request) => (applicationId, appSize, parts) => __awaiter(void 0, void 0, void 0, function* () {
    const partForRequest = (part) => ({
        md5: part.md5,
        partNumber: part.partNumber,
    });
    const resp = yield retryRequest({
        data: {
            appSize,
            parts: parts.map(partForRequest),
        },
        method: 'POST',
        url: `/synthetics/mobile/applications/${applicationId}/multipart-presigned-urls`,
    }, request);
    return resp.data;
});
const uploadMobileApplicationPart = (request) => (parts, multipartPresignedUrlsParams) => __awaiter(void 0, void 0, void 0, function* () {
    const promises = Object.entries(multipartPresignedUrlsParams.urls).map(([partNumber, presignedUrl]) => __awaiter(void 0, void 0, void 0, function* () {
        const resp = yield retryRequest({
            data: parts[Number(partNumber) - 1].blob,
            headers: {
                'Content-MD5': parts[Number(partNumber) - 1].md5,
                // Presigned URL *requires* unset content-type since it's used for signature
                // We can clear axios default by setting to null
                // https://github.com/axios/axios/pull/1845
                // eslint-disable-next-line no-null/no-null
                'Content-Type': null,
            },
            maxBodyLength: Infinity,
            maxContentLength: Infinity,
            method: 'PUT',
            url: presignedUrl,
        }, request);
        const quotedEtag = resp.headers.etag;
        return {
            ETag: quotedEtag.replace(/"/g, ''),
            PartNumber: Number(partNumber),
        };
    }));
    return Promise.all(promises);
});
const completeMultipartMobileApplicationUpload = (request) => (applicationId, uploadId, key, uploadPartResponses) => __awaiter(void 0, void 0, void 0, function* () {
    yield retryRequest({
        data: {
            key,
            parts: uploadPartResponses,
            uploadId,
        },
        method: 'POST',
        url: `/synthetics/mobile/applications/${applicationId}/multipart-upload-complete`,
    }, request);
});
exports.completeMultipartMobileApplicationUpload = completeMultipartMobileApplicationUpload;
const createMobileVersion = (request) => (version) => __awaiter(void 0, void 0, void 0, function* () {
    const resp = yield retryRequest({
        data: version,
        method: 'POST',
        url: `/synthetics/mobile/applications/versions`,
    }, request);
    return resp.data;
});
const retryOn5xxErrors = (retries, error) => {
    // Retry on Node.js errors for both retry policies.
    if (retries < MAX_RETRIES && (0, exports.isNodeError)(error)) {
        return LARGE_DELAY_BETWEEN_RETRIES;
    }
    if (retries < MAX_RETRIES && (0, exports.is5xxError)(error)) {
        return DELAY_BETWEEN_RETRIES;
    }
};
const retryOn5xxOr404Errors = (retries, error) => {
    const retryOn5xxDelay = retryOn5xxErrors(retries, error);
    if (retryOn5xxDelay) {
        return retryOn5xxDelay;
    }
    if (retries < MAX_RETRIES && (0, exports.isNotFoundError)(error)) {
        return DELAY_BETWEEN_RETRIES;
    }
};
const getErrorHttpStatus = (error) => { var _a; return 'status' in error ? error.status : (_a = error.response) === null || _a === void 0 ? void 0 : _a.status; };
const isForbiddenError = (error) => getErrorHttpStatus(error) === 403;
exports.isForbiddenError = isForbiddenError;
const isNotFoundError = (error) => getErrorHttpStatus(error) === 404;
exports.isNotFoundError = isNotFoundError;
const isNodeError = (error) => !!error && 'code' in error;
exports.isNodeError = isNodeError;
const is5xxError = (error) => {
    const statusCode = getErrorHttpStatus(error);
    return statusCode && statusCode >= 500 && statusCode <= 599;
};
exports.is5xxError = is5xxError;
const retryRequest = (args, request, retryPolicy = retryOn5xxErrors) => (0, public_1.retry)(() => request(args), retryPolicy);
const apiConstructor = (configuration) => {
    const { baseUrl, baseIntakeUrl, baseUnstableUrl, apiKey, appKey, proxyOpts } = configuration;
    const baseOptions = { apiKey, appKey, proxyOpts };
    const request = (0, utils_1.getRequestBuilder)(Object.assign(Object.assign({}, baseOptions), { baseUrl }));
    const requestUnstable = (0, utils_1.getRequestBuilder)(Object.assign(Object.assign({}, baseOptions), { baseUrl: baseUnstableUrl }));
    const requestIntake = (0, utils_1.getRequestBuilder)(Object.assign(Object.assign({}, baseOptions), { baseUrl: baseIntakeUrl }));
    return {
        getBatch: getBatch(request),
        getMobileApplicationPresignedURLs: getMobileApplicationPresignedURLs(requestUnstable),
        getTest: getTest(request),
        getSyntheticsOrgSettings: getSyntheticsOrgSettings(request),
        getTunnelPresignedURL: getTunnelPresignedURL(requestIntake),
        pollResults: pollResults(request),
        searchTests: searchTests(request),
        triggerTests: triggerTests(requestIntake),
        uploadMobileApplicationPart: uploadMobileApplicationPart(request),
        completeMultipartMobileApplicationUpload: (0, exports.completeMultipartMobileApplicationUpload)(requestUnstable),
        createMobileVersion: createMobileVersion(requestUnstable),
    };
};
exports.apiConstructor = apiConstructor;
const getApiHelper = (config) => {
    if (!config.appKey) {
        throw new errors_1.CriticalError('MISSING_APP_KEY', 'App key is required');
    }
    if (!config.apiKey) {
        throw new errors_1.CriticalError('MISSING_API_KEY', 'API key is required');
    }
    return (0, exports.apiConstructor)({
        apiKey: config.apiKey,
        appKey: config.appKey,
        baseIntakeUrl: (0, public_1.getDatadogHost)({ useIntake: true, apiVersion: 'v1', config }),
        baseUnstableUrl: (0, public_1.getDatadogHost)({ useIntake: false, apiVersion: 'unstable', config }),
        baseUrl: (0, public_1.getDatadogHost)({ useIntake: false, apiVersion: 'v1', config }),
        proxyOpts: config.proxy,
    });
};
exports.getApiHelper = getApiHelper;
//# sourceMappingURL=api.js.map