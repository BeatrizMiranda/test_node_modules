"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.execute = exports.executeWithDetails = exports.getTestsList = exports.executeTests = void 0;
const utils_1 = require("../../helpers/utils");
const api_1 = require("./api");
const errors_1 = require("./errors");
const default_1 = require("./reporters/default");
const junit_1 = require("./reporters/junit");
const run_tests_command_1 = require("./run-tests-command");
const tunnel_1 = require("./tunnel");
const public_1 = require("./utils/public");
const executeTests = (reporter, config, suites) => __awaiter(void 0, void 0, void 0, function* () {
    const api = (0, api_1.getApiHelper)(config);
    const publicIdsFromCli = config.publicIds.map((id) => {
        var _a;
        return ({
            config: Object.assign(Object.assign({}, config.global), (((_a = config.locations) === null || _a === void 0 ? void 0 : _a.length) ? { locations: config.locations } : {})),
            id,
        });
    });
    let testsToTrigger;
    let tunnel;
    const stopTunnel = () => __awaiter(void 0, void 0, void 0, function* () {
        if (tunnel) {
            yield tunnel.stop();
        }
    });
    if (publicIdsFromCli.length) {
        testsToTrigger = publicIdsFromCli;
    }
    else {
        try {
            testsToTrigger = yield (0, exports.getTestsList)(api, config, reporter, suites);
        }
        catch (error) {
            throw new errors_1.CriticalError((0, api_1.isForbiddenError)(error) ? 'AUTHORIZATION_ERROR' : 'UNAVAILABLE_TEST_CONFIG', error.message);
        }
    }
    if (!testsToTrigger.length) {
        throw new errors_1.CiError('NO_TESTS_TO_RUN');
    }
    let testsToTriggerResult;
    try {
        const triggerFromSearch = !!config.testSearchQuery;
        testsToTriggerResult = yield (0, public_1.getTestsToTrigger)(api, testsToTrigger, reporter, triggerFromSearch, config.failOnMissingTests, config.tunnel);
    }
    catch (error) {
        if (error instanceof errors_1.CiError) {
            throw error;
        }
        throw new errors_1.CriticalError((0, api_1.isForbiddenError)(error) ? 'AUTHORIZATION_ERROR' : 'UNAVAILABLE_TEST_CONFIG', error.message);
    }
    const { tests, overriddenTestsToTrigger, initialSummary } = testsToTriggerResult;
    // All tests have been skipped or are missing.
    if (!tests.length) {
        throw new errors_1.CiError('NO_TESTS_TO_RUN');
    }
    const publicIdsToTrigger = tests.map(({ public_id }) => public_id);
    if (config.tunnel) {
        let presignedURL;
        try {
            // Get the pre-signed URL to connect to the tunnel service
            presignedURL = (yield api.getTunnelPresignedURL(publicIdsToTrigger)).url;
        }
        catch (error) {
            throw new errors_1.CriticalError('UNAVAILABLE_TUNNEL_CONFIG', error.message);
        }
        // Open a tunnel to Datadog
        try {
            const tunnelProxyAgent = (0, utils_1.getProxyAgent)(config.proxy);
            const tunnelReporter = (0, default_1.getTunnelReporter)(reporter);
            tunnel = new tunnel_1.Tunnel(presignedURL, publicIdsToTrigger, tunnelProxyAgent, tunnelReporter);
            const tunnelInfo = yield tunnel.start();
            overriddenTestsToTrigger.forEach((testToTrigger) => {
                testToTrigger.tunnel = tunnelInfo;
            });
        }
        catch (error) {
            yield stopTunnel();
            throw new errors_1.CriticalError('TUNNEL_START_FAILED', error.message);
        }
    }
    let trigger;
    try {
        trigger = yield (0, public_1.runTests)(api, overriddenTestsToTrigger, config.selectiveRerun);
    }
    catch (error) {
        yield stopTunnel();
        throw new errors_1.CriticalError('TRIGGER_TESTS_FAILED', error.message);
    }
    try {
        const maxPollingTimeout = Math.max(...testsToTrigger.map((t) => t.config.pollingTimeout || config.pollingTimeout));
        const { datadogSite, failOnCriticalErrors, failOnTimeout, subdomain } = config;
        const results = yield (0, public_1.waitForResults)(api, trigger, tests, { datadogSite, failOnCriticalErrors, failOnTimeout, subdomain, maxPollingTimeout }, reporter, tunnel);
        return {
            results,
            summary: Object.assign(Object.assign({}, initialSummary), { batchId: trigger.batch_id }),
        };
    }
    catch (error) {
        throw new errors_1.CriticalError('POLL_RESULTS_FAILED', error.message);
    }
    finally {
        yield stopTunnel();
    }
});
exports.executeTests = executeTests;
const getTestListBySearchQuery = (api, globalConfigOverride, testSearchQuery) => __awaiter(void 0, void 0, void 0, function* () {
    const testSearchResults = yield api.searchTests(testSearchQuery);
    return testSearchResults.tests.map((test) => ({
        config: globalConfigOverride,
        id: test.public_id,
        suite: `Query: ${testSearchQuery}`,
    }));
});
const getTestsList = (api, config, reporter, suites = []) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    // If "testSearchQuery" is provided, always default to running it.
    if (config.testSearchQuery) {
        const testsToTriggerBySearchQuery = yield getTestListBySearchQuery(api, config.global, config.testSearchQuery);
        if (testsToTriggerBySearchQuery.length > run_tests_command_1.MAX_TESTS_TO_TRIGGER) {
            reporter.error(`More than ${run_tests_command_1.MAX_TESTS_TO_TRIGGER} tests returned by search query, only the first ${run_tests_command_1.MAX_TESTS_TO_TRIGGER} will be fetched.\n`);
        }
        return testsToTriggerBySearchQuery;
    }
    const suitesFromFiles = (yield Promise.all(config.files.map((glob) => (0, public_1.getSuites)(glob, reporter))))
        .reduce((acc, val) => acc.concat(val), [])
        .filter((suite) => !!suite.content.tests);
    suites.push(...suitesFromFiles);
    const configFromEnvironment = ((_a = config.locations) === null || _a === void 0 ? void 0 : _a.length) ? { locations: config.locations } : {};
    const overrideTestConfig = (test) => 
    // {} < global < ENV < test file
    (Object.assign(Object.assign(Object.assign({}, config.global), configFromEnvironment), test.config));
    const testsToTrigger = suites
        .map((suite) => suite.content.tests.map((test) => ({
        config: overrideTestConfig(test),
        id: test.id,
        suite: suite.name,
    })))
        .reduce((acc, suiteTests) => acc.concat(suiteTests), []);
    return testsToTrigger;
});
exports.getTestsList = getTestsList;
const executeWithDetails = (runConfig, { jUnitReport, reporters, runId, suites }) => __awaiter(void 0, void 0, void 0, function* () {
    const startTime = Date.now();
    const localConfig = Object.assign(Object.assign({}, run_tests_command_1.DEFAULT_COMMAND_CONFIG), runConfig);
    // We don't want to have default globs in case suites are given.
    if (!runConfig.files && (suites === null || suites === void 0 ? void 0 : suites.length)) {
        localConfig.files = [];
    }
    // Handle reporters for the run.
    const localReporters = [];
    // If the config asks for specific reporters.
    if (reporters) {
        for (const reporter of reporters) {
            // Add our own reporters if required.
            if (reporter === 'junit') {
                localReporters.push(new junit_1.JUnitReporter({
                    context: process,
                    jUnitReport: jUnitReport || './junit.xml',
                    runName: `Run ${runId || 'undefined'}`,
                }));
            }
            if (reporter === 'default') {
                localReporters.push(new default_1.DefaultReporter({ context: process }));
            }
            // This is a custom reporter, so simply add it.
            if (typeof reporter !== 'string') {
                localReporters.push(reporter);
            }
        }
    }
    else {
        localReporters.push(new default_1.DefaultReporter({ context: process }));
    }
    const mainReporter = (0, public_1.getReporter)(localReporters);
    const { results, summary } = yield (0, exports.executeTests)(mainReporter, localConfig, suites);
    const orgSettings = yield (0, public_1.getOrgSettings)(mainReporter, localConfig);
    (0, public_1.renderResults)({
        config: localConfig,
        reporter: mainReporter,
        results,
        orgSettings,
        startTime,
        summary,
    });
    (0, public_1.reportExitLogs)(mainReporter, localConfig, { results });
    const exitCode = (0, public_1.toExitCode)((0, public_1.getExitReason)(localConfig, { results }));
    return {
        results,
        summary,
        exitCode,
    };
});
exports.executeWithDetails = executeWithDetails;
const execute = (runConfig, executeOptions) => __awaiter(void 0, void 0, void 0, function* () {
    const { exitCode } = yield (0, exports.executeWithDetails)(runConfig, executeOptions);
    return exitCode;
});
exports.execute = execute;
//# sourceMappingURL=run-tests-lib.js.map