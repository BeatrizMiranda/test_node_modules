"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.reportCiError = exports.pluralize = exports.getDatadogHost = exports.toExitCode = exports.getExitReason = exports.reportExitLogs = exports.renderResults = exports.sortResultsByOutcome = exports.getResultUrl = exports.getBatchUrl = exports.getAppBaseURL = exports.parseVariablesFromCli = exports.retry = exports.fetchTest = exports.runTests = exports.getTestsToTrigger = exports.isDeviceIdSet = exports.getTestAndOverrideConfig = exports.getReporter = exports.getResultDuration = exports.createInitialSummary = exports.waitForResults = exports.isResultSkippedBySelectiveRerun = exports.getOrgSettings = exports.wait = exports.getFilePathRelativeToRepo = exports.getSuites = exports.getResultOutcome = exports.PASSED_RESULT_OUTCOMES = exports.hasResultPassed = exports.isTestSupportedByTunnel = exports.getStrictestExecutionRule = exports.getExecutionRule = exports.setCiTriggerApp = exports.getOverriddenConfig = exports.ciTriggerApp = exports.readableOperation = void 0;
const child_process_1 = require("child_process");
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const process_1 = __importDefault(require("process"));
const util_1 = require("util");
const chalk_1 = __importDefault(require("chalk"));
const deep_extend_1 = __importDefault(require("deep-extend"));
const glob_1 = __importDefault(require("glob"));
const app_1 = require("../../../helpers/app");
const ci_1 = require("../../../helpers/ci");
const tags_1 = require("../../../helpers/tags");
const utils_1 = require("../../../helpers/utils");
const api_1 = require("../api");
const errors_1 = require("../errors");
const interfaces_1 = require("../interfaces");
const mobile_1 = require("../mobile");
const run_tests_command_1 = require("../run-tests-command");
const internal_1 = require("./internal");
const POLLING_INTERVAL = 5000; // In ms
const PUBLIC_ID_REGEX = /^[\d\w]{3}-[\d\w]{3}-[\d\w]{3}$/;
const TEMPLATE_REGEX = /{{\s*([^{}]*?)\s*}}/g;
exports.readableOperation = {
    [interfaces_1.Operator.contains]: 'should contain',
    [interfaces_1.Operator.doesNotContain]: 'should not contain',
    [interfaces_1.Operator.is]: 'should be',
    [interfaces_1.Operator.isNot]: 'should not be',
    [interfaces_1.Operator.lessThan]: 'should be less than',
    [interfaces_1.Operator.matches]: 'should match',
    [interfaces_1.Operator.doesNotMatch]: 'should not match',
    [interfaces_1.Operator.isInLessThan]: 'will expire in less than',
    [interfaces_1.Operator.isInMoreThan]: 'will expire in more than',
    [interfaces_1.Operator.lessThanOrEqual]: 'should be less than or equal to',
    [interfaces_1.Operator.moreThan]: 'should be more than',
    [interfaces_1.Operator.moreThanOrEqual]: 'should be less than or equal to',
    [interfaces_1.Operator.validatesJSONPath]: 'assert on JSONPath extracted value',
    [interfaces_1.Operator.validatesXPath]: 'assert on XPath extracted value',
};
const template = (st, context) => st.replace(TEMPLATE_REGEX, (match, p1) => (p1 in context ? context[p1] : match));
exports.ciTriggerApp = process_1.default.env.DATADOG_SYNTHETICS_CI_TRIGGER_APP || 'npm_package';
const getOverriddenConfig = (test, publicId, reporter, config) => {
    let overriddenConfig = {
        public_id: publicId,
    };
    if (!config || !Object.keys(config).length) {
        return overriddenConfig;
    }
    const executionRule = (0, internal_1.getOverriddenExecutionRule)(test, config);
    if (executionRule) {
        overriddenConfig.executionRule = executionRule;
    }
    overriddenConfig = Object.assign(Object.assign({}, overriddenConfig), (0, utils_1.pick)(config, [
        'allowInsecureCertificates',
        'basicAuth',
        'body',
        'bodyType',
        'cookies',
        'defaultStepTimeout',
        'deviceIds',
        'followRedirects',
        'headers',
        'locations',
        'pollingTimeout',
        'resourceUrlSubstitutionRegexes',
        'retry',
        'startUrlSubstitutionRegex',
        'testTimeout',
        'tunnel',
        'variables',
    ]));
    if ((test.type === 'browser' || test.subtype === 'http') && config.startUrl) {
        overriddenConfig.startUrl = template(config.startUrl, Object.assign({}, process_1.default.env));
    }
    return overriddenConfig;
};
exports.getOverriddenConfig = getOverriddenConfig;
const setCiTriggerApp = (source) => {
    exports.ciTriggerApp = source;
};
exports.setCiTriggerApp = setCiTriggerApp;
const getExecutionRule = (test, configOverride) => {
    var _a, _b, _c, _d;
    if (configOverride && configOverride.executionRule) {
        return (0, exports.getStrictestExecutionRule)(configOverride.executionRule, (_b = (_a = test === null || test === void 0 ? void 0 : test.options) === null || _a === void 0 ? void 0 : _a.ci) === null || _b === void 0 ? void 0 : _b.executionRule);
    }
    return ((_d = (_c = test === null || test === void 0 ? void 0 : test.options) === null || _c === void 0 ? void 0 : _c.ci) === null || _d === void 0 ? void 0 : _d.executionRule) || interfaces_1.ExecutionRule.BLOCKING;
};
exports.getExecutionRule = getExecutionRule;
const getStrictestExecutionRule = (configRule, testRule) => {
    if (configRule === interfaces_1.ExecutionRule.SKIPPED || testRule === interfaces_1.ExecutionRule.SKIPPED) {
        return interfaces_1.ExecutionRule.SKIPPED;
    }
    if (configRule === interfaces_1.ExecutionRule.NON_BLOCKING || testRule === interfaces_1.ExecutionRule.NON_BLOCKING) {
        return interfaces_1.ExecutionRule.NON_BLOCKING;
    }
    if (configRule === interfaces_1.ExecutionRule.BLOCKING || testRule === interfaces_1.ExecutionRule.BLOCKING) {
        return interfaces_1.ExecutionRule.BLOCKING;
    }
    return interfaces_1.ExecutionRule.BLOCKING;
};
exports.getStrictestExecutionRule = getStrictestExecutionRule;
const isTestSupportedByTunnel = (test) => {
    var _a;
    return (test.type === 'browser' ||
        test.subtype === 'http' ||
        (test.subtype === 'multi' && ((_a = test.config.steps) === null || _a === void 0 ? void 0 : _a.every((step) => step.subtype === 'http'))));
};
exports.isTestSupportedByTunnel = isTestSupportedByTunnel;
const hasResultPassed = (serverResult, hasTimedOut, failOnCriticalErrors, failOnTimeout) => {
    if (serverResult.unhealthy && !failOnCriticalErrors) {
        return true;
    }
    if (hasTimedOut && !failOnTimeout) {
        return true;
    }
    if (typeof serverResult.passed !== 'undefined') {
        return serverResult.passed;
    }
    if (typeof serverResult.failure !== 'undefined') {
        return false;
    }
    return true;
};
exports.hasResultPassed = hasResultPassed;
exports.PASSED_RESULT_OUTCOMES = [
    "passed" /* ResultOutcome.Passed */,
    "passed-non-blocking" /* ResultOutcome.PassedNonBlocking */,
    "previously-passed" /* ResultOutcome.PreviouslyPassed */,
];
const getResultOutcome = (result) => {
    if ((0, exports.isResultSkippedBySelectiveRerun)(result)) {
        return "previously-passed" /* ResultOutcome.PreviouslyPassed */;
    }
    const executionRule = result.executionRule;
    if (result.passed) {
        if (executionRule === interfaces_1.ExecutionRule.NON_BLOCKING) {
            return "passed-non-blocking" /* ResultOutcome.PassedNonBlocking */;
        }
        return "passed" /* ResultOutcome.Passed */;
    }
    if (executionRule === interfaces_1.ExecutionRule.NON_BLOCKING) {
        return "failed-non-blocking" /* ResultOutcome.FailedNonBlocking */;
    }
    return "failed" /* ResultOutcome.Failed */;
};
exports.getResultOutcome = getResultOutcome;
const getSuites = (GLOB, reporter) => __awaiter(void 0, void 0, void 0, function* () {
    reporter.log(`Finding files matching ${path.resolve(process_1.default.cwd(), GLOB)}\n`);
    const files = yield (0, util_1.promisify)(glob_1.default)(GLOB);
    if (files.length) {
        reporter.log(`\nGot test files:\n${files.map((file) => `  - ${file}\n`).join('')}\n`);
    }
    else {
        reporter.log('\nNo test files found.\n\n');
    }
    return Promise.all(files.map((file) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            const content = yield (0, util_1.promisify)(fs.readFile)(file, 'utf8');
            const suiteName = yield (0, exports.getFilePathRelativeToRepo)(file);
            return { name: suiteName, content: JSON.parse(content) };
        }
        catch (e) {
            throw new Error(`Unable to read and parse the test file ${file}`);
        }
    })));
});
exports.getSuites = getSuites;
const getFilePathRelativeToRepo = (filePath) => __awaiter(void 0, void 0, void 0, function* () {
    const parentDirectory = path.dirname(filePath);
    const filename = path.basename(filePath);
    let relativeDirectory;
    try {
        const { stdout } = yield (0, util_1.promisify)(child_process_1.exec)('git rev-parse --show-toplevel');
        const repoTopLevel = stdout.trim();
        relativeDirectory = path.relative(repoTopLevel, parentDirectory);
    }
    catch (_a) {
        // We aren't in a git repository: fall back to the given path, relative to the process working directory.
        relativeDirectory = path.relative(process_1.default.cwd(), parentDirectory);
    }
    return path.join(relativeDirectory, filename);
});
exports.getFilePathRelativeToRepo = getFilePathRelativeToRepo;
const wait = (duration) => __awaiter(void 0, void 0, void 0, function* () { return new Promise((resolve) => setTimeout(resolve, duration)); });
exports.wait = wait;
const getBatch = (api, trigger) => __awaiter(void 0, void 0, void 0, function* () {
    var _b;
    try {
        const batch = yield api.getBatch(trigger.batch_id);
        return batch;
    }
    catch (e) {
        throw new api_1.EndpointError(`Failed to get batch: ${(0, api_1.formatBackendErrors)(e)}\n`, (_b = e.response) === null || _b === void 0 ? void 0 : _b.status);
    }
});
const getTestByPublicId = (id, tests) => tests.find((t) => t.public_id === id);
const getPollResultMap = (api, resultIds) => __awaiter(void 0, void 0, void 0, function* () {
    var _c;
    try {
        const pollResults = yield api.pollResults(resultIds);
        const pollResultMap = {};
        pollResults.forEach((r) => (pollResultMap[r.resultID] = r));
        return pollResultMap;
    }
    catch (e) {
        throw new api_1.EndpointError(`Failed to poll results: ${(0, api_1.formatBackendErrors)(e)}\n`, (_c = e.response) === null || _c === void 0 ? void 0 : _c.status);
    }
});
const getOrgSettings = (reporter, config) => __awaiter(void 0, void 0, void 0, function* () {
    const apiHelper = (0, api_1.getApiHelper)(config);
    try {
        return yield apiHelper.getSyntheticsOrgSettings();
    }
    catch (e) {
        reporter.error(`Failed to get settings: ${(0, api_1.formatBackendErrors)(e)}`);
    }
});
exports.getOrgSettings = getOrgSettings;
const waitForBatchToFinish = (api, maxPollingTimeout, trigger, resultDisplayInfo, reporter) => __awaiter(void 0, void 0, void 0, function* () {
    const maxPollingDate = Date.now() + maxPollingTimeout;
    const emittedResultIndexes = new Set();
    while (true) {
        const batch = yield getBatch(api, trigger);
        const hasBatchExceededMaxPollingDate = Date.now() >= maxPollingDate;
        // The backend is expected to handle the time out of the batch by eventually changing its status to `failed`.
        // But `hasBatchExceededMaxPollingDate` is a safety in case it fails to do that.
        const shouldContinuePolling = batch.status === 'in_progress' && !hasBatchExceededMaxPollingDate;
        const receivedResults = reportReceivedResults(batch, emittedResultIndexes, reporter);
        const residualResults = batch.results.filter((_, index) => !emittedResultIndexes.has(index));
        // For the last iteration, the full up-to-date data has to be fetched to compute this function's return value,
        // while only the [received + residual] results have to be reported.
        const resultIdsToFetch = (shouldContinuePolling ? receivedResults : batch.results).flatMap((r) => (0, internal_1.isResultInBatchSkippedBySelectiveRerun)(r) ? [] : [r.result_id]);
        const resultsToReport = receivedResults.concat(shouldContinuePolling ? [] : residualResults);
        const pollResultMap = yield getPollResultMap(api, resultIdsToFetch);
        reportResults(resultsToReport, pollResultMap, resultDisplayInfo, hasBatchExceededMaxPollingDate, reporter);
        if (!shouldContinuePolling) {
            return batch.results.map((r) => getResultFromBatch(r, pollResultMap, resultDisplayInfo, hasBatchExceededMaxPollingDate));
        }
        reportWaitingTests(trigger, batch, resultDisplayInfo, reporter);
        yield (0, exports.wait)(POLLING_INTERVAL);
    }
});
const isResultSkippedBySelectiveRerun = (result) => {
    var _a;
    return ((_a = result.selectiveRerun) === null || _a === void 0 ? void 0 : _a.decision) === 'skip';
};
exports.isResultSkippedBySelectiveRerun = isResultSkippedBySelectiveRerun;
const reportReceivedResults = (batch, emittedResultIndexes, reporter) => {
    const receivedResults = [];
    for (const [index, result] of batch.results.entries()) {
        if (result.status !== 'in_progress' && !emittedResultIndexes.has(index)) {
            emittedResultIndexes.add(index);
            reporter.resultReceived(result);
            receivedResults.push(result);
        }
    }
    return receivedResults;
};
const reportResults = (results, pollResultMap, resultDisplayInfo, hasBatchExceededMaxPollingDate, reporter) => {
    const baseUrl = (0, exports.getAppBaseURL)(resultDisplayInfo.options);
    for (const result of results) {
        reporter.resultEnd(getResultFromBatch(result, pollResultMap, resultDisplayInfo, hasBatchExceededMaxPollingDate), baseUrl);
    }
};
const reportWaitingTests = (trigger, batch, resultDisplayInfo, reporter) => {
    const baseUrl = (0, exports.getAppBaseURL)(resultDisplayInfo.options);
    const { tests } = resultDisplayInfo;
    const inProgressPublicIds = new Set();
    const skippedBySelectiveRerunPublicIds = new Set();
    for (const result of batch.results) {
        if (result.status === 'in_progress') {
            inProgressPublicIds.add(result.test_public_id);
        }
        if ((0, internal_1.isResultInBatchSkippedBySelectiveRerun)(result)) {
            skippedBySelectiveRerunPublicIds.add(result.test_public_id);
        }
    }
    const remainingTests = [];
    let skippedCount = 0;
    for (const test of tests) {
        if (inProgressPublicIds.has(test.public_id)) {
            remainingTests.push(test);
        }
        if (skippedBySelectiveRerunPublicIds.has(test.public_id)) {
            skippedCount++;
        }
    }
    reporter.testsWait(remainingTests, baseUrl, trigger.batch_id, skippedCount);
};
const getResultFromBatch = (resultInBatch, pollResultMap, resultDisplayInfo, hasBatchExceededMaxPollingDate) => {
    var _a, _b, _c;
    const { getLocation, options, tests } = resultDisplayInfo;
    const hasTimedOut = (_a = resultInBatch.timed_out) !== null && _a !== void 0 ? _a : hasBatchExceededMaxPollingDate;
    const test = getTestByPublicId(resultInBatch.test_public_id, tests);
    if ((0, internal_1.isResultInBatchSkippedBySelectiveRerun)(resultInBatch)) {
        return {
            executionRule: resultInBatch.execution_rule,
            passed: true,
            resultId: (0, internal_1.getResultIdOrLinkedResultId)(resultInBatch),
            selectiveRerun: resultInBatch.selective_rerun,
            test,
            timedOut: hasTimedOut,
        };
    }
    const pollResult = pollResultMap[resultInBatch.result_id];
    if (hasTimedOut) {
        pollResult.result.failure = { code: 'TIMEOUT', message: 'Result timed out' };
        pollResult.result.passed = false;
    }
    return {
        executionRule: resultInBatch.execution_rule,
        location: getLocation(resultInBatch.location, test),
        passed: (0, exports.hasResultPassed)(pollResult.result, hasTimedOut, (_b = options.failOnCriticalErrors) !== null && _b !== void 0 ? _b : false, (_c = options.failOnTimeout) !== null && _c !== void 0 ? _c : false),
        result: pollResult.result,
        resultId: (0, internal_1.getResultIdOrLinkedResultId)(resultInBatch),
        selectiveRerun: resultInBatch.selective_rerun,
        test: (0, deep_extend_1.default)({}, test, pollResult.check),
        timedOut: hasTimedOut,
        timestamp: pollResult.timestamp,
    };
};
// XXX: We shouldn't export functions that take an `APIHelper` because the `utils` module is exported while `api` is not.
const waitForResults = (api, trigger, tests, options, reporter, tunnel) => __awaiter(void 0, void 0, void 0, function* () {
    let isTunnelConnected = true;
    if (tunnel) {
        tunnel
            .keepAlive()
            .then(() => (isTunnelConnected = false))
            .catch(() => (isTunnelConnected = false));
    }
    reporter.testsWait(tests, (0, exports.getAppBaseURL)(options), trigger.batch_id);
    const locationNames = trigger.locations.reduce((mapping, location) => {
        mapping[location.name] = location.display_name;
        return mapping;
    }, {});
    const getLocation = (dcId, test) => {
        const hasTunnel = !!tunnel && (0, exports.isTestSupportedByTunnel)(test);
        return hasTunnel ? 'Tunneled' : locationNames[dcId] || dcId;
    };
    const resultDisplayInfo = {
        getLocation,
        options,
        tests,
    };
    const results = yield waitForBatchToFinish(api, options.maxPollingTimeout, trigger, resultDisplayInfo, reporter);
    if (tunnel && !isTunnelConnected) {
        reporter.error('The tunnel has stopped working, this may have affected the results.');
    }
    return results;
});
exports.waitForResults = waitForResults;
const createInitialSummary = () => ({
    criticalErrors: 0,
    expected: 0,
    failed: 0,
    failedNonBlocking: 0,
    passed: 0,
    previouslyPassed: 0,
    skipped: 0,
    testsNotFound: new Set(),
    timedOut: 0,
});
exports.createInitialSummary = createInitialSummary;
const getResultDuration = (result) => {
    if ('duration' in result) {
        return Math.round(result.duration);
    }
    if ('timings' in result) {
        return Math.round(result.timings.total);
    }
    return 0;
};
exports.getResultDuration = getResultDuration;
const getReporter = (reporters) => ({
    error: (error) => {
        for (const reporter of reporters) {
            if (typeof reporter.error === 'function') {
                reporter.error(error);
            }
        }
    },
    initErrors: (errors) => {
        for (const reporter of reporters) {
            if (typeof reporter.initErrors === 'function') {
                reporter.initErrors(errors);
            }
        }
    },
    log: (log) => {
        for (const reporter of reporters) {
            if (typeof reporter.log === 'function') {
                reporter.log(log);
            }
        }
    },
    reportStart: (timings) => {
        for (const reporter of reporters) {
            if (typeof reporter.reportStart === 'function') {
                reporter.reportStart(timings);
            }
        }
    },
    resultEnd: (result, baseUrl) => {
        for (const reporter of reporters) {
            if (typeof reporter.resultEnd === 'function') {
                reporter.resultEnd(result, baseUrl);
            }
        }
    },
    resultReceived: (result) => {
        for (const reporter of reporters) {
            if (typeof reporter.resultReceived === 'function') {
                reporter.resultReceived(result);
            }
        }
    },
    runEnd: (summary, baseUrl, orgSettings) => {
        for (const reporter of reporters) {
            if (typeof reporter.runEnd === 'function') {
                reporter.runEnd(summary, baseUrl, orgSettings);
            }
        }
    },
    testTrigger: (test, testId, executionRule, config) => {
        for (const reporter of reporters) {
            if (typeof reporter.testTrigger === 'function') {
                reporter.testTrigger(test, testId, executionRule, config);
            }
        }
    },
    testWait: (test) => {
        for (const reporter of reporters) {
            if (typeof reporter.testWait === 'function') {
                reporter.testWait(test);
            }
        }
    },
    testsWait: (tests, baseUrl, batchId, skippedCount) => {
        for (const reporter of reporters) {
            if (typeof reporter.testsWait === 'function') {
                reporter.testsWait(tests, baseUrl, batchId, skippedCount);
            }
        }
    },
});
exports.getReporter = getReporter;
const getTest = (api, { id, suite }) => __awaiter(void 0, void 0, void 0, function* () {
    var _d;
    try {
        const test = Object.assign(Object.assign({}, (yield api.getTest(id))), { suite });
        return { test };
    }
    catch (error) {
        if ((0, api_1.isNotFoundError)(error)) {
            const errorMessage = (0, api_1.formatBackendErrors)(error);
            return { errorMessage: `[${chalk_1.default.bold.dim(id)}] ${chalk_1.default.yellow.bold('Test not found')}: ${errorMessage}` };
        }
        throw new api_1.EndpointError(`Failed to get test: ${(0, api_1.formatBackendErrors)(error)}\n`, (_d = error.response) === null || _d === void 0 ? void 0 : _d.status);
    }
});
// XXX: We shouldn't export functions that take an `APIHelper` because the `utils` module is exported while `api` is not.
const getTestAndOverrideConfig = (api, { config, id, suite }, reporter, summary, isTunnelEnabled) => __awaiter(void 0, void 0, void 0, function* () {
    var _e, _f;
    const normalizedId = PUBLIC_ID_REGEX.test(id) ? id : id.substring(id.lastIndexOf('/') + 1);
    const testResult = yield getTest(api, { config, id: normalizedId, suite });
    if ('errorMessage' in testResult) {
        summary.testsNotFound.add(normalizedId);
        return { errorMessage: testResult.errorMessage };
    }
    const { test } = testResult;
    const overriddenConfig = (0, exports.getOverriddenConfig)(test, normalizedId, reporter, config);
    const testExecutionRule = (_f = (_e = test === null || test === void 0 ? void 0 : test.options) === null || _e === void 0 ? void 0 : _e.ci) === null || _f === void 0 ? void 0 : _f.executionRule;
    const executionRule = overriddenConfig.executionRule || testExecutionRule || interfaces_1.ExecutionRule.BLOCKING;
    reporter.testTrigger(test, normalizedId, executionRule, config);
    if (executionRule === interfaces_1.ExecutionRule.SKIPPED) {
        summary.skipped++;
        return { overriddenConfig };
    }
    reporter.testWait(test);
    if (isTunnelEnabled && !(0, exports.isTestSupportedByTunnel)(test)) {
        const details = [`public ID: ${test.public_id}`, `type: ${test.type}`];
        if (test.subtype) {
            details.push(`sub-type: ${test.subtype}`);
        }
        if (test.subtype === 'multi') {
            const unsupportedStepSubTypes = (test.config.steps || [])
                .filter((step) => step.subtype !== 'http')
                .map(({ subtype }) => subtype);
            details.push(`step sub-types: [${unsupportedStepSubTypes.join(', ')}]`);
        }
        throw new errors_1.CriticalError('TUNNEL_NOT_SUPPORTED', `The tunnel is only supported with HTTP API tests and Browser tests (${details.join(', ')}).`);
    }
    return { overriddenConfig, test };
});
exports.getTestAndOverrideConfig = getTestAndOverrideConfig;
const isDeviceIdSet = (result) => 'device' in result && result.device !== undefined;
exports.isDeviceIdSet = isDeviceIdSet;
// XXX: We shouldn't export functions that take an `APIHelper` because the `utils` module is exported while `api` is not.
const getTestsToTrigger = (api, triggerConfigs, reporter, triggerFromSearch, failOnMissingTests, isTunnelEnabled) => __awaiter(void 0, void 0, void 0, function* () {
    const errorMessages = [];
    // When too many tests are triggered, if fetched from a search query: simply trim them and show a warning,
    // otherwise: retrieve them and fail later if still exceeding without skipped/missing tests.
    if (triggerConfigs.length > run_tests_command_1.MAX_TESTS_TO_TRIGGER && triggerFromSearch) {
        triggerConfigs.splice(run_tests_command_1.MAX_TESTS_TO_TRIGGER);
        const maxTests = chalk_1.default.bold(run_tests_command_1.MAX_TESTS_TO_TRIGGER);
        errorMessages.push(chalk_1.default.yellow(`More than ${maxTests} tests returned by search query, only the first ${maxTests} were fetched.\n`));
    }
    const initialSummary = (0, exports.createInitialSummary)();
    const testsAndConfigsOverride = yield Promise.all(triggerConfigs.map((triggerConfig) => (0, exports.getTestAndOverrideConfig)(api, triggerConfig, reporter, initialSummary, isTunnelEnabled)));
    // Keep track of uploaded applications to avoid uploading them twice.
    const uploadedApplicationByPath = {};
    for (const item of testsAndConfigsOverride) {
        // Ignore not found and skipped tests.
        if ('errorMessage' in item || !('test' in item)) {
            continue;
        }
        const { test, overriddenConfig } = item;
        if (test.type === 'mobile') {
            const { config: userConfigOverride } = triggerConfigs.find(({ id }) => id === test.public_id);
            try {
                yield (0, mobile_1.uploadApplicationAndOverrideConfig)(api, test, userConfigOverride, overriddenConfig, uploadedApplicationByPath);
            }
            catch (e) {
                throw new errors_1.CriticalError('UPLOAD_MOBILE_APPLICATION_TESTS_FAILED', e.message);
            }
        }
    }
    const overriddenTestsToTrigger = [];
    const waitedTests = [];
    testsAndConfigsOverride.forEach((item) => {
        if ('errorMessage' in item) {
            errorMessages.push(item.errorMessage);
        }
        if ('overriddenConfig' in item) {
            overriddenTestsToTrigger.push(item.overriddenConfig);
        }
        if ('test' in item) {
            waitedTests.push(item.test);
        }
    });
    // Display errors at the end of all tests for better visibility.
    reporter.initErrors(errorMessages);
    if (failOnMissingTests && initialSummary.testsNotFound.size > 0) {
        const testsNotFoundListStr = [...initialSummary.testsNotFound].join(', ');
        throw new errors_1.CiError('MISSING_TESTS', testsNotFoundListStr);
    }
    if (!overriddenTestsToTrigger.length) {
        throw new errors_1.CiError('NO_TESTS_TO_RUN');
    }
    else if (overriddenTestsToTrigger.length > run_tests_command_1.MAX_TESTS_TO_TRIGGER) {
        throw new errors_1.CriticalError('TOO_MANY_TESTS_TO_TRIGGER', `Cannot trigger more than ${run_tests_command_1.MAX_TESTS_TO_TRIGGER} tests (received ${triggerConfigs.length})`);
    }
    return { tests: waitedTests, overriddenTestsToTrigger, initialSummary };
});
exports.getTestsToTrigger = getTestsToTrigger;
// XXX: We shouldn't export functions that take an `APIHelper` because the `utils` module is exported while `api` is not.
const runTests = (api, testsToTrigger, selectiveRerun = false) => __awaiter(void 0, void 0, void 0, function* () {
    var _g;
    const payload = {
        tests: testsToTrigger,
        options: {
            selective_rerun: selectiveRerun,
        },
    };
    const tagsToLimit = {
        [tags_1.GIT_COMMIT_MESSAGE]: 500,
    };
    const ciMetadata = (0, ci_1.getCIMetadata)(tagsToLimit);
    if (ciMetadata) {
        payload.metadata = ciMetadata;
    }
    try {
        return yield api.triggerTests(payload);
    }
    catch (e) {
        const errorMessage = (0, api_1.formatBackendErrors)(e);
        const testIds = testsToTrigger.map((t) => t.public_id).join(',');
        // Rewrite error message
        throw new api_1.EndpointError(`[${testIds}] Failed to trigger tests: ${errorMessage}\n`, (_g = e.response) === null || _g === void 0 ? void 0 : _g.status);
    }
});
exports.runTests = runTests;
const fetchTest = (publicId, config) => __awaiter(void 0, void 0, void 0, function* () {
    const apiHelper = (0, api_1.getApiHelper)(config);
    return apiHelper.getTest(publicId);
});
exports.fetchTest = fetchTest;
const retry = (func, shouldRetryAfterWait) => __awaiter(void 0, void 0, void 0, function* () {
    const trier = (retries = 0) => __awaiter(void 0, void 0, void 0, function* () {
        try {
            return yield func();
        }
        catch (e) {
            const waiter = shouldRetryAfterWait(retries, e);
            if (waiter) {
                yield (0, exports.wait)(waiter);
                return trier(retries + 1);
            }
            throw e;
        }
    });
    return trier();
});
exports.retry = retry;
const parseVariablesFromCli = (variableArguments = [], logFunction) => {
    const variables = {};
    for (const variableArgument of variableArguments) {
        const separatorIndex = variableArgument.indexOf('=');
        if (separatorIndex === -1) {
            logFunction(`Ignoring variable "${variableArgument}" as separator "=" was not found`);
            continue;
        }
        if (separatorIndex === 0) {
            logFunction(`Ignoring variable "${variableArgument}" as variable name is empty`);
            continue;
        }
        const key = variableArgument.substring(0, separatorIndex);
        const value = variableArgument.substring(separatorIndex + 1);
        variables[key] = value;
    }
    return Object.keys(variables).length > 0 ? variables : undefined;
};
exports.parseVariablesFromCli = parseVariablesFromCli;
// XXX: `CommandConfig` should be replaced by `SyntheticsCIConfig` here because it's the smallest
//      interface that we need, and it's better semantically.
const getAppBaseURL = ({ datadogSite, subdomain }) => {
    return (0, app_1.getCommonAppBaseURL)(datadogSite, subdomain);
};
exports.getAppBaseURL = getAppBaseURL;
const getBatchUrl = (baseUrl, batchId) => `${baseUrl}synthetics/explorer/ci?batchResultId=${batchId}`;
exports.getBatchUrl = getBatchUrl;
const getResultUrl = (baseUrl, test, resultId) => {
    const ciQueryParam = 'from_ci=true';
    const testDetailUrl = `${baseUrl}synthetics/details/${test.public_id}`;
    if (test.type === 'browser') {
        return `${testDetailUrl}/result/${resultId}?${ciQueryParam}`;
    }
    return `${testDetailUrl}?resultId=${resultId}&${ciQueryParam}`;
};
exports.getResultUrl = getResultUrl;
/**
 * Sort results with the following rules:
 * - Passed results come first
 * - Then non-blocking failed results
 * - And finally failed results
 */
const sortResultsByOutcome = () => {
    const outcomeWeight = {
        ["previously-passed" /* ResultOutcome.PreviouslyPassed */]: 1,
        ["passed-non-blocking" /* ResultOutcome.PassedNonBlocking */]: 2,
        ["passed" /* ResultOutcome.Passed */]: 3,
        ["failed-non-blocking" /* ResultOutcome.FailedNonBlocking */]: 4,
        ["failed" /* ResultOutcome.Failed */]: 5,
    };
    return (r1, r2) => outcomeWeight[(0, exports.getResultOutcome)(r1)] - outcomeWeight[(0, exports.getResultOutcome)(r2)];
};
exports.sortResultsByOutcome = sortResultsByOutcome;
const renderResults = ({ config, orgSettings, reporter, results, startTime, summary, }) => {
    reporter.reportStart({ startTime });
    if (!config.failOnTimeout) {
        if (!summary.timedOut) {
            summary.timedOut = 0;
        }
    }
    if (!config.failOnCriticalErrors) {
        if (!summary.criticalErrors) {
            summary.criticalErrors = 0;
        }
    }
    for (const result of results) {
        if (!config.failOnTimeout && result.timedOut) {
            summary.timedOut++;
        }
        if ((0, internal_1.hasResult)(result) && result.result.unhealthy && !config.failOnCriticalErrors) {
            summary.criticalErrors++;
        }
        const resultOutcome = (0, exports.getResultOutcome)(result);
        if (result.executionRule !== interfaces_1.ExecutionRule.SKIPPED || resultOutcome === "previously-passed" /* ResultOutcome.PreviouslyPassed */) {
            summary.expected++;
        }
        if (["passed" /* ResultOutcome.Passed */, "passed-non-blocking" /* ResultOutcome.PassedNonBlocking */].includes(resultOutcome)) {
            summary.passed++;
        }
        else if (resultOutcome === "previously-passed" /* ResultOutcome.PreviouslyPassed */) {
            summary.passed++;
            summary.previouslyPassed++;
        }
        else if (resultOutcome === "failed-non-blocking" /* ResultOutcome.FailedNonBlocking */) {
            summary.failedNonBlocking++;
        }
        else {
            summary.failed++;
        }
    }
    reporter.runEnd(summary, (0, exports.getAppBaseURL)(config), orgSettings);
};
exports.renderResults = renderResults;
const reportExitLogs = (reporter, config, { results, error }) => {
    if (!config.failOnTimeout && (results === null || results === void 0 ? void 0 : results.some((result) => result.timedOut))) {
        reporter.error(chalk_1.default.yellow('Because `failOnTimeout` is disabled, the command will succeed. ' +
            'Use `failOnTimeout: true` to make it fail instead.\n'));
    }
    if (!config.failOnCriticalErrors && error instanceof errors_1.CriticalError) {
        reporter.error(chalk_1.default.yellow('Because `failOnCriticalErrors` is not set or disabled, the command will succeed. ' +
            'Use `failOnCriticalErrors: true` to make it fail instead.\n'));
    }
    if (error instanceof errors_1.CiError) {
        (0, exports.reportCiError)(error, reporter);
    }
};
exports.reportExitLogs = reportExitLogs;
const getExitReason = (config, { results, error }) => {
    if (results === null || results === void 0 ? void 0 : results.some((result) => (0, exports.getResultOutcome)(result) === "failed" /* ResultOutcome.Failed */)) {
        return 'failing-tests';
    }
    if (error instanceof errors_1.CiError) {
        // Ensure the command fails if search query starts returning no results
        if (config.failOnMissingTests && ['MISSING_TESTS', 'NO_TESTS_TO_RUN'].includes(error.code)) {
            return 'missing-tests';
        }
        if (error instanceof errors_1.CriticalError) {
            if (config.failOnCriticalErrors) {
                return 'critical-error';
            }
        }
    }
    return 'passed';
};
exports.getExitReason = getExitReason;
const toExitCode = (reason) => {
    return reason === 'passed' ? 0 : 1;
};
exports.toExitCode = toExitCode;
const getDatadogHost = (hostConfig) => {
    const { useIntake, apiVersion, config } = hostConfig;
    const apiPath = apiVersion === 'v1' ? 'api/v1' : 'api/unstable';
    let host = `https://api.${config.datadogSite}`;
    const hostOverride = process_1.default.env.DD_API_HOST_OVERRIDE;
    if (hostOverride) {
        host = hostOverride;
    }
    else if (useIntake && (config.datadogSite === 'datadoghq.com' || config.datadogSite === 'datad0g.com')) {
        host = `https://intake.synthetics.${config.datadogSite}`;
    }
    return `${host}/${apiPath}`;
};
exports.getDatadogHost = getDatadogHost;
const pluralize = (word, count) => (count === 1 ? word : `${word}s`);
exports.pluralize = pluralize;
const reportCiError = (error, reporter) => {
    switch (error.code) {
        case 'NO_TESTS_TO_RUN':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: No tests to run ')}\n${error.message}\n\n`);
            break;
        case 'MISSING_TESTS':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: some tests are missing ')}\n${error.message}\n\n`);
            break;
        // Critical command errors
        case 'AUTHORIZATION_ERROR':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: authorization error ')}\n${error.message}\n\n`);
            reporter.log('Credentials refused, make sure `apiKey`, `appKey` and `datadogSite` are correct.\n');
            break;
        case 'INVALID_CONFIG':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: invalid config ')}\n${error.message}\n\n`);
            break;
        case 'MISSING_APP_KEY':
            reporter.error(`Missing ${chalk_1.default.red.bold('DATADOG_APP_KEY')} in your environment.\n`);
            break;
        case 'MISSING_API_KEY':
            reporter.error(`Missing ${chalk_1.default.red.bold('DATADOG_API_KEY')} in your environment.\n`);
            break;
        case 'POLL_RESULTS_FAILED':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: unable to poll test results ')}\n${error.message}\n\n`);
            break;
        case 'TUNNEL_START_FAILED':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: unable to start tunnel ')}\n${error.message}\n\n`);
            break;
        case 'TOO_MANY_TESTS_TO_TRIGGER':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: too many tests to trigger ')}\n${error.message}\n\n`);
            break;
        case 'TRIGGER_TESTS_FAILED':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: unable to trigger tests ')}\n${error.message}\n\n`);
            break;
        case 'UNAVAILABLE_TEST_CONFIG':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: unable to obtain test configurations with search query ')}\n${error.message}\n\n`);
            break;
        case 'UNAVAILABLE_TUNNEL_CONFIG':
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR: unable to get tunnel configuration ')}\n${error.message}\n\n`);
            break;
        default:
            reporter.error(`\n${chalk_1.default.bgRed.bold(' ERROR ')}\n${error.message}\n\n`);
    }
};
exports.reportCiError = reportCiError;
//# sourceMappingURL=public.js.map