"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.shouldUpdateStepForTracesMerging = exports.updateStepObject = exports.injectContextIntoLambdaPayload = exports.buildLogAccessPolicyName = exports.parseArn = exports.getStepFunctionLogGroupArn = exports.isValidArn = exports.buildSubscriptionFilterName = exports.buildLogGroupName = exports.buildArn = exports.displayChanges = void 0;
const deep_object_diff_1 = require("deep-object-diff");
const awsCommands_1 = require("./awsCommands");
const constants_1 = require("./constants");
const displayChanges = (stepFunctionArn, context, commandName, dryRun, params, previousParams) => {
    context.stdout.write(`\n${dryRun ? '\nPlanning for' : 'Will apply'} the following change:\n`);
    if (previousParams !== undefined) {
        context.stdout.write(`\n${commandName}:\nFrom:\n${JSON.stringify((0, deep_object_diff_1.diff)(params, previousParams), undefined, 2)}\nTo:\n${JSON.stringify((0, deep_object_diff_1.diff)(previousParams, params), undefined, 2)}\n`);
    }
    else {
        context.stdout.write(`\n${commandName}:\n${JSON.stringify(params, undefined, 2)}\n`);
    }
};
exports.displayChanges = displayChanges;
const buildArn = (partition, service, region, accountId, resourceType, resourceId) => {
    return `arn:${partition}:${service}:${region}:${accountId}:${resourceType}:${resourceId}`;
};
exports.buildArn = buildArn;
const buildLogGroupName = (stepFunctionName, env) => {
    return `/aws/vendedlogs/states/${stepFunctionName}-Logs${env !== undefined ? '-' + env : ''}`;
};
exports.buildLogGroupName = buildLogGroupName;
const buildSubscriptionFilterName = (stepFunctionName) => {
    return `${stepFunctionName}-${constants_1.DD_CI_IDENTIFYING_STRING}`;
};
exports.buildSubscriptionFilterName = buildSubscriptionFilterName;
const isValidArn = (str) => {
    const arnFields = str.split(':');
    return arnFields.length >= 7 && arnFields[0] === 'arn';
};
exports.isValidArn = isValidArn;
const getStepFunctionLogGroupArn = (stepFunction) => {
    var _a, _b, _c;
    const [logDestinations] = (_b = (_a = stepFunction.loggingConfiguration) === null || _a === void 0 ? void 0 : _a.destinations) !== null && _b !== void 0 ? _b : [{ cloudWatchLogsLogGroup: {} }];
    return (_c = logDestinations.cloudWatchLogsLogGroup) === null || _c === void 0 ? void 0 : _c.logGroupArn;
};
exports.getStepFunctionLogGroupArn = getStepFunctionLogGroupArn;
const parseArn = (arn) => {
    const [, partition, , region, accountId, , resourceName] = arn.split(':');
    return {
        partition,
        region,
        accountId,
        resourceName,
    };
};
exports.parseArn = parseArn;
const buildLogAccessPolicyName = (stepFunction) => {
    return `LogsDeliveryAccessPolicy-${stepFunction.name}`;
};
exports.buildLogAccessPolicyName = buildLogAccessPolicyName;
const injectContextIntoLambdaPayload = (describeStateMachineCommandOutput, stepFunctionsClient, context, dryRun) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    if (typeof describeStateMachineCommandOutput.definition !== 'string') {
        return;
    }
    let definitionHasBeenUpdated = false;
    const definitionObj = JSON.parse(describeStateMachineCommandOutput.definition);
    for (const stepName in definitionObj.States) {
        if (definitionObj.States.hasOwnProperty(stepName)) {
            const step = definitionObj.States[stepName];
            if ((0, exports.shouldUpdateStepForTracesMerging)(step)) {
                (0, exports.updateStepObject)(step);
                definitionHasBeenUpdated = true;
            }
            else if ((_a = step.Resource) === null || _a === void 0 ? void 0 : _a.startsWith('arn:aws:lambda')) {
                context.stdout.write(`[Warn] Step ${stepName} may be using the basic legacy integration, which does not support merging lambda trace(s) with Step Functions trace. 
          To merge lambda trace(s) with Step Functions trace, please consider using the latest integration. 
          More details can be found on https://docs.aws.amazon.com/step-functions/latest/dg/connect-lambda.html \n`);
            }
        }
    }
    if (definitionHasBeenUpdated) {
        yield (0, awsCommands_1.updateStateMachineDefinition)(stepFunctionsClient, describeStateMachineCommandOutput, definitionObj, context, dryRun);
    }
});
exports.injectContextIntoLambdaPayload = injectContextIntoLambdaPayload;
const updateStepObject = ({ Parameters }) => {
    if (Parameters) {
        Parameters[`Payload.$`] = 'States.JsonMerge($$, $, false)';
    }
};
exports.updateStepObject = updateStepObject;
const shouldUpdateStepForTracesMerging = (step) => {
    // is default lambda api
    if (step.Resource === 'arn:aws:states:::lambda:invoke') {
        if (!step.Parameters) {
            return false;
        }
        // payload field not set
        if (!step.Parameters.hasOwnProperty('Payload.$')) {
            return true;
        }
        // default payload
        if (step.Parameters['Payload.$'] === '$') {
            return true;
        }
    }
    return false;
};
exports.shouldUpdateStepForTracesMerging = shouldUpdateStepForTracesMerging;
//# sourceMappingURL=helpers.js.map