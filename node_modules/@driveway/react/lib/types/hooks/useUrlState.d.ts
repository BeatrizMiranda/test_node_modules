/**
 * `useUrlState` is a hook for managing URL query params as component state. It
 * similar to `useState` except that it maintains the state in the URL by using
 * the `navigate` hook. Using this hook in any component that can control the
 * URL such as filtering or sorting allows the user to make changes and be able
 * to navigate backward and forward through their changes.
 *
 * This removes the need for any complex state management or decoding logic. Any
 * logic that relies on the entire URL search string can then just use the
 * `useLocation` hook combined with `URLSearchParams`.
 *
 * Examples
 *
 * ```
 * const FilterStatus = () => {
 *   const [filter, setFilter] = useUrlState("status");
 *   return (
 *     <button onClick={() => setFilter("pending")}>
 *       Filter Pending
 *     </button>
 *   );
 * };
 * ```
 *
 * Then you can use the URL state as below:
 *
 * ```
 * const useFilterLookup = () => {
 *   const location = useLocation();
 *   const debouncedLocation = useDebounce(location);
 *
 *   useEffect(() => {
 *     const filters = query.parse(debouncedLocation.search);
 *     // filters would look like: { status: "pending" }
 *     // use filters in API request. This will re-run any time
 *     // debouncedLocation changes
 *   }, [debouncedLocation]);
 * };
 * ```
 */
import { Dispatch, SetStateAction } from "react";
interface StateUrl {
    hash: string;
    search: string;
}
interface NavigateFunction {
    ({ hash, search }: StateUrl): any;
}
declare type UseUrlOpts = {
    showDefaultInUrl?: boolean;
};
declare type UseUrlStateResult<Data> = [Data, Dispatch<SetStateAction<Data>>];
interface ToString {
    toString: () => string;
}
declare const useUrlState: (key: string, defaultValue: ToString, navigate?: NavigateFunction, { showDefaultInUrl }?: UseUrlOpts) => UseUrlStateResult<ToString>;
export default useUrlState;
export type { UseUrlOpts, UseUrlStateResult, NavigateFunction, StateUrl };
