"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _path = require("path");

var path = _interopRequireWildcard(_path);

var _tools = require("../../tools");

var _readonly = require("../../readonly");

var _readonly2 = _interopRequireDefault(_readonly);

var _logger = require("../../logger");

var _logger2 = _interopRequireDefault(_logger);

var _handlers = require("./handlers");

var _handlers2 = _interopRequireDefault(_handlers);

var _utils = require("../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

exports.default = class {
  constructor(config, mgmtClient) {
    this.filePath = config.AUTH0_INPUT_FILE;
    this.config = config;
    this.mappings = config.AUTH0_KEYWORD_REPLACE_MAPPINGS;
    this.mgmtClient = mgmtClient;
    this.assets = {
      exclude: {
        rules: config.AUTH0_EXCLUDED_RULES || [],
        clients: config.AUTH0_EXCLUDED_CLIENTS || [],
        databases: config.AUTH0_EXCLUDED_DATABASES || [],
        connections: config.AUTH0_EXCLUDED_CONNECTIONS || [],
        resourceServers: config.AUTH0_EXCLUDED_RESOURCE_SERVERS || [],
        defaults: config.AUTH0_EXCLUDED_DEFAULTS || []
      }
    };
  }

  loadFile(f, folder) {
    const basePath = path.join(this.filePath, folder);
    let toLoad = path.join(basePath, f);

    if (!(0, _utils.isFile)(toLoad)) {
      toLoad = f;
    }

    return (0, _tools.loadFile)(toLoad, this.mappings);
  }

  async load() {
    if ((0, _utils.isDirectory)(this.filePath)) {
      _logger2.default.info(`Processing directory ${this.filePath}`);

      Object.values(_handlers2.default).forEach(handler => {
        const parsed = handler.parse(this);
        Object.entries(parsed).forEach(([k, v]) => {
          this.assets[k] = v;
        });
      });
      return;
    }

    throw new Error(`Not sure what to do with, ${this.filePath} as it is not a directory...`);
  }

  async dump() {
    const auth0 = new _tools.Auth0(this.mgmtClient, this.assets, (0, _utils.toConfigFn)(this.config));

    _logger2.default.info('Loading Auth0 Tenant Data');

    await auth0.loadAll();
    this.assets = auth0.assets;
    this.assets = (0, _readonly2.default)(this.assets, this.config);
    this.assets.clientsOrig = [...this.assets.clients];

    if (!this.config.AUTH0_EXPORT_IDENTIFIERS) {
      this.assets = (0, _utils.stripIdentifiers)(auth0, this.assets);
    }

    await Promise.all(Object.entries(_handlers2.default).map(async ([name, handler]) => {
      try {
        const data = await handler.dump(this);

        if (data) {
          _logger2.default.info(`Exporting ${name}`);
        }
      } catch (err) {
        _logger2.default.debug(err.stack);

        throw new Error(`Problem exporting ${name}`);
      }
    }));
  }

};