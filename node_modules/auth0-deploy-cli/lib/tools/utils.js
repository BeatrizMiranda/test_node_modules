"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.keywordReplace = keywordReplace;
exports.convertClientNameToId = convertClientNameToId;
exports.convertClientNamesToIds = convertClientNamesToIds;
exports.loadFile = loadFile;
exports.flatten = flatten;
exports.dumpJSON = dumpJSON;
exports.calcChanges = calcChanges;
exports.stripFields = stripFields;
exports.getEnabledClients = getEnabledClients;
exports.duplicateItems = duplicateItems;
exports.filterExcluded = filterExcluded;
exports.areArraysEquals = areArraysEquals;

var _path = require("path");

var _path2 = _interopRequireDefault(_path);

var _fs = require("fs");

var _fs2 = _interopRequireDefault(_fs);

var _dotProp = require("dot-prop");

var _dotProp2 = _interopRequireDefault(_dotProp);

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

var _logger = require("./logger");

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function keywordReplace(input, mappings) {
  if (mappings && Object.keys(mappings).length > 0) {
    Object.keys(mappings).forEach(function (key) {
      const re = new RegExp(`##${key}##`, 'g');
      input = input.replace(re, mappings[key]);
    });
    Object.keys(mappings).forEach(function (key) {
      const re = new RegExp(`@@${key}@@`, 'g');
      input = input.replace(re, JSON.stringify(mappings[key]));
    });
  }

  return input;
}

function convertClientNameToId(name, clients) {
  const found = clients.find(c => c.name === name);
  return found && found.client_id || name;
}

function convertClientNamesToIds(names, clients) {
  const resolvedNames = names.map(name => ({
    name,
    resolved: false
  }));
  const result = clients.reduce((acc, client) => {
    if (names.includes(client.name)) {
      const index = resolvedNames.findIndex(item => item.name === client.name);
      resolvedNames[index].resolved = true;
      acc.push(client.client_id);
    }

    return acc;
  }, []);
  const unresolved = resolvedNames.filter(item => !item.resolved).map(item => item.name);
  return [...unresolved, ...result];
}

function loadFile(file, mappings) {
  const f = _path2.default.resolve(file);

  try {
    _fs2.default.accessSync(f, _fs2.default.F_OK);

    if (mappings) {
      return keywordReplace(_fs2.default.readFileSync(f, 'utf8'), mappings);
    }

    return _fs2.default.readFileSync(f, 'utf8');
  } catch (error) {
    throw new Error(`Unable to load file ${f} due to ${error}`);
  }
}

function flatten(list) {
  return list.reduce((a, b) => a.concat(Array.isArray(b) ? flatten(b) : b), []);
}

function dumpJSON(obj, spacing = 0) {
  return JSON.stringify(obj, null, spacing);
}

function processChangedObjectFields(handler, desiredAssetState, currentAssetState, objectFields = [], allowDelete = false) {
  const desiredAssetStateWithChanges = { ...desiredAssetState
  };

  for (const fieldName of objectFields) {
    if (desiredAssetState[fieldName] && Object.keys(desiredAssetState[fieldName]).length) {
      if (currentAssetState[fieldName]) {
        for (const currentObjectFieldPropertyName of Object.keys(currentAssetState[fieldName])) {
          if (desiredAssetState[fieldName][currentObjectFieldPropertyName] === undefined) {
            if (allowDelete) {
              desiredAssetStateWithChanges[fieldName][currentObjectFieldPropertyName] = null;
            } else {
              _logger2.default.warn(`Detected that the ${fieldName} of the following ${handler.name} should be deleted. Doing so may be destructive.\nYou can enable deletes by setting 'AUTH0_ALLOW_DELETE' to true in the config\n${handler.objString(currentAssetState)}`);
            }
          }
        }
      }
    } else if (allowDelete) {
      desiredAssetStateWithChanges[fieldName] = {};
    } else {
      delete desiredAssetStateWithChanges[fieldName];

      _logger2.default.warn(`Detected that the ${fieldName} of the following ${handler.name} should be emptied. Doing so may be destructive.\nYou can enable deletes by setting 'AUTH0_ALLOW_DELETE' to true in the config\n${handler.objString(currentAssetState)}`);
    }
  }

  return desiredAssetStateWithChanges;
}

function calcChanges(handler, assets, existing, identifiers = ['id', 'name'], objectFields = [], allowDelete = false) {
  const update = [];
  let del = [...existing];
  let create = [...assets];
  const conflicts = [];

  const findByKeyValue = (key, value, arr) => arr.find(e => {
    if (Array.isArray(key)) {
      const values = key.map(k => e[k]);

      if (values.every(v => v)) {
        return value === values.join('-');
      }
    } else {
      return e[key] === value;
    }

    return false;
  });

  const processAssets = (id, arr) => {
    arr.forEach(asset => {
      let assetIdValue;

      if (Array.isArray(id)) {
        const values = id.map(i => asset[i]);

        if (values.every(v => v)) {
          assetIdValue = values.join('-');
        }
      } else {
        assetIdValue = asset[id];
      }

      if (assetIdValue) {
        const found = findByKeyValue(id, assetIdValue, del);

        if (found) {
          del = del.filter(e => e !== found);
          create = create.filter(e => e !== asset);
          update.push({ ...identifiers.reduce((obj, i) => {
              if (found[i]) obj[i] = found[i];
              return obj;
            }, {}),
            ...(objectFields.length ? processChangedObjectFields(handler, asset, found, objectFields, allowDelete) : asset)
          });
        }
      }
    });
  };

  for (const id of identifiers) {
    processAssets(id, [...create]);
  }

  if (identifiers.includes('name')) {
    const uniqueID = identifiers[0];
    const futureAssets = [...create, ...update];
    futureAssets.forEach(a => {
      const inDeleted = del.filter(e => e.name === a.name && e[uniqueID] !== a[uniqueID])[0];

      if (!inDeleted) {
        const conflict = existing.filter(e => e.name === a.name && e[uniqueID] !== a[uniqueID])[0];

        if (conflict) {
          const temp = Math.random().toString(36).substr(2, 5);
          conflicts.push({ ...conflict,
            name: `${conflict.name}-${temp}`
          });
        }
      }
    });
  }

  return {
    del,
    update,
    conflicts,
    create
  };
}

function stripFields(obj, fields) {
  const stripped = [];
  const newObj = { ...obj
  };
  fields.forEach(f => {
    if (_dotProp2.default.get(newObj, f) !== undefined) {
      _dotProp2.default.delete(newObj, f);

      stripped.push(f);
    }
  });

  if (stripped) {
    const name = ['id', 'client_id', 'template', 'name'].reduce((n, k) => newObj[k] || n, '');

    _logger2.default.debug(`Stripping "${name}" read-only fields ${JSON.stringify(stripped)}`);
  }

  return newObj;
}

function getEnabledClients(assets, connection, existing, clients) {
  const excludedClientsByNames = assets.exclude && assets.exclude.clients || [];
  const excludedClients = convertClientNamesToIds(excludedClientsByNames, clients);
  const enabledClients = [...convertClientNamesToIds(connection.enabled_clients || [], clients).filter(item => ![...excludedClientsByNames, ...excludedClients].includes(item))];
  existing.forEach(conn => {
    if (conn.name === connection.name) {
      excludedClients.forEach(excludedClient => {
        if (conn.enabled_clients.includes(excludedClient)) {
          enabledClients.push(excludedClient);
        }
      });
    }
  });
  return enabledClients;
}

function duplicateItems(arr, key) {
  const duplicates = arr.reduce((accum, obj) => {
    const keyValue = obj[key];

    if (keyValue) {
      if (!(keyValue in accum)) accum[keyValue] = [];
      accum[keyValue].push(obj);
    }

    return accum;
  }, {});
  return Object.values(duplicates).filter(g => g.length > 1);
}

function filterExcluded(changes, exclude) {
  const {
    del,
    update,
    create,
    conflicts
  } = changes;

  if (!exclude.length) {
    return changes;
  }

  const filter = list => list.filter(item => !exclude.includes(item.name));

  return {
    del: filter(del),
    update: filter(update),
    create: filter(create),
    conflicts: filter(conflicts)
  };
}

function areArraysEquals(x, y) {
  return _lodash2.default.isEqual(x && x.sort(), y && y.sort());
}