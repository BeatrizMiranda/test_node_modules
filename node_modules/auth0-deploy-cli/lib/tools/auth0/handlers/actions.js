"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.schema = undefined;

var _dec, _class;

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

var _default = require("./default");

var _default2 = _interopRequireDefault(_default);

var _logger = require("../../logger");

var _logger2 = _interopRequireDefault(_logger);

var _utils = require("../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

const MAX_ACTION_DEPLOY_RETRY = 60;
const schema = exports.schema = {
  type: 'array',
  items: {
    type: 'object',
    required: ['name', 'supported_triggers', 'code'],
    additionalProperties: false,
    properties: {
      code: {
        type: 'string',
        default: ''
      },
      runtime: {
        type: 'string'
      },
      dependencies: {
        type: 'array',
        items: {
          type: 'object',
          additionalProperties: false,
          properties: {
            name: {
              type: 'string'
            },
            version: {
              type: 'string'
            },
            registry_url: {
              type: 'string'
            }
          }
        }
      },
      secrets: {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            name: {
              type: 'string'
            },
            value: {
              type: 'string'
            },
            updated_at: {
              type: 'string',
              format: 'date-time'
            }
          }
        }
      },
      name: {
        type: 'string',
        default: ''
      },
      supported_triggers: {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            id: {
              type: 'string',
              default: ''
            },
            version: {
              type: 'string'
            },
            url: {
              type: 'string'
            }
          }
        }
      },
      deployed: {
        type: 'boolean'
      },
      status: {
        type: 'string'
      }
    }
  }
};

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

function isActionsDisabled(err) {
  const errorBody = _lodash2.default.get(err, 'originalError.response.body') || {};
  return err.statusCode === 403 && errorBody.errorCode === 'feature_not_enabled';
}

let ActionHandler = (_dec = (0, _default.order)('60'), (_class = class ActionHandler extends _default2.default {
  constructor(options) {
    super({ ...options,
      type: 'actions',
      functions: {
        create: action => this.createAction(action),
        delete: action => this.deleteAction(action)
      },
      stripUpdateFields: ['deployed', 'status']
    });
  }

  async createAction(action) {
    const addAction = { ...action
    };
    delete addAction.deployed;
    delete addAction.status;
    const createdAction = await this.client.actions.create(addAction);
    action.id = createdAction.id;
    return createdAction;
  }

  async deleteAction(action) {
    if (!this.client.actions || typeof this.client.actions.delete !== 'function') {
      return [];
    }

    return this.client.actions.delete({
      id: action.id,
      force: true
    });
  }

  objString(action) {
    return super.objString({
      id: action.id,
      name: action.name
    });
  }

  async deployActions(actions) {
    await this.client.pool.addEachTask({
      data: actions || [],
      generator: action => this.deployAction(action).then(() => {
        _logger2.default.info(`Deployed [${this.type}]: ${this.objString(action)}`);
      }).catch(err => {
        throw new Error(`Problem Deploying ${this.type} ${this.objString(action)}\n${err}`);
      })
    }).promise();
  }

  async deployAction(action) {
    try {
      await this.client.actions.deploy({
        id: action.id
      });
    } catch (err) {
      if (err.message && err.message.includes('must be in the \'built\' state')) {
        if (!action.retry_count) {
          _logger2.default.info(`[${this.type}]: Waiting for build to complete ${this.objString(action)}`);

          action.retry_count = 1;
        }

        if (action.retry_count > MAX_ACTION_DEPLOY_RETRY) {
          throw err;
        }

        await sleep(1000);
        action.retry_count += 1;
        await this.deployAction(action);
      }
    }
  }

  async actionChanges(action, found) {
    const actionChanges = {};

    if (!action.deployed) {
      if (action.code !== found.code) {
        actionChanges.code = action.code;
      }

      if (action.runtime !== found.runtime) {
        actionChanges.runtime = action.runtime;
      }

      if (!(0, _utils.areArraysEquals)(action.dependencies, found.dependencies)) {
        actionChanges.dependencies = action.dependencies;
      }
    }

    if (!(0, _utils.areArraysEquals)(action.supported_triggers, found.supported_triggers)) {
      actionChanges.supported_triggers = action.supported_triggers;
    }

    return actionChanges;
  }

  async getType() {
    if (this.existing) return this.existing;

    if (!this.client.actions || typeof this.client.actions.getAll !== 'function') {
      return [];
    }

    try {
      this.existing = await this.client.actions.getAll({
        paginate: true
      });
      return this.existing;
    } catch (err) {
      if (err.statusCode === 403 || err.statusCode === 404 || err.statusCode === 501) {
        return [];
      }

      if (isActionsDisabled(err)) {
        _logger2.default.info('Skipping actions because it is not enabled.');

        return [];
      }

      throw err;
    }
  }

  async processChanges(assets) {
    const {
      actions
    } = assets;
    if (!actions) return;
    const changes = await this.calcChanges(assets);
    await super.processChanges(assets, changes);
    const deployActions = [];
    deployActions.push(...changes.create.filter(action => action.deployed));
    deployActions.push(...changes.update.filter(action => action.deployed));
    await this.deployActions(deployActions);
  }

}, (_applyDecoratedDescriptor(_class.prototype, "processChanges", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, "processChanges"), _class.prototype)), _class));
exports.default = ActionHandler;