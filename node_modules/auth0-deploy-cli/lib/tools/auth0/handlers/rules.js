"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.schema = exports.excludeSchema = undefined;

var _ValidationError = require("../../ValidationError");

var _ValidationError2 = _interopRequireDefault(_ValidationError);

var _utils = require("../../utils");

var _default = require("./default");

var _default2 = _interopRequireDefault(_default);

var _logger = require("../../logger");

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const excludeSchema = exports.excludeSchema = {
  type: 'array',
  items: {
    type: 'string'
  }
};
const schema = exports.schema = {
  type: 'array',
  items: {
    type: 'object',
    default: [],
    properties: {
      script: {
        type: 'string',
        description: 'A script that contains the rule\'s code',
        default: ''
      },
      name: {
        type: 'string',
        description: 'The name of the rule. Can only contain alphanumeric characters, spaces and \'-\'. Can neither start nor end with \'-\' or spaces',
        pattern: '^[^-\\s][a-zA-Z0-9-\\s]+[^-\\s]$'
      },
      order: {
        type: ['number', 'null'],
        description: 'The rule\'s order in relation to other rules. A rule with a lower order than another rule executes first.',
        default: null
      },
      enabled: {
        type: 'boolean',
        description: 'true if the rule is enabled, false otherwise',
        default: true
      },
      stage: {
        type: 'string',
        description: 'The rule\'s execution stage',
        default: 'login_success',
        enum: ['login_success', 'login_failure', 'pre_authorize']
      }
    },
    required: ['name']
  }
};

class RulesHandler extends _default2.default {
  constructor(options) {
    super({ ...options,
      type: 'rules',
      stripUpdateFields: ['stage']
    });
  }

  async getType() {
    if (this.existing) return this.existing;
    this.existing = await this.client.rules.getAll({
      paginate: true,
      include_totals: true
    });
    return this.existing;
  }

  objString(rule) {
    return super.objString({
      name: rule.name,
      order: rule.order
    });
  }

  async calcChanges(assets, includeExcluded = false) {
    let {
      rules
    } = assets;
    const excludedRules = assets.exclude && assets.exclude.rules || [];
    let existing = await this.getType();

    if (!includeExcluded) {
      rules = rules.filter(r => !excludedRules.includes(r.name));
      existing = existing.filter(r => !excludedRules.includes(r.name));
    }

    const {
      del,
      update,
      create,
      conflicts
    } = (0, _utils.calcChanges)(this, rules, existing, ['id', 'name']);
    const futureRules = [...create, ...update];
    const futureMaxOrder = Math.max(...futureRules.map(r => r.order));
    const existingMaxOrder = Math.max(...existing.map(r => r.order));
    let nextOrderNo = Math.max(futureMaxOrder, existingMaxOrder);
    const reOrder = futureRules.reduce((accum, r) => {
      const conflict = existing.find(f => r.order === f.order && r.name !== f.name);

      if (conflict) {
        nextOrderNo += 1;
        accum.push({ ...conflict,
          order: nextOrderNo
        });
      }

      return accum;
    }, []);
    return {
      del,
      update,
      create,
      reOrder,
      conflicts
    };
  }

  async validate(assets) {
    const {
      rules
    } = assets;
    if (!rules) return;
    const excludedRules = assets.exclude && assets.exclude.rules || [];
    const {
      update,
      create,
      del
    } = await this.calcChanges(assets, true);
    const futureRules = [...create, ...update, ...del.filter(r => excludedRules.includes(r.name))];
    const rulesSameOrder = (0, _utils.duplicateItems)(futureRules, 'order');

    if (rulesSameOrder.length > 0) {
      const formatted = rulesSameOrder.map(dups => dups.map(d => `${d.name}`));
      throw new _ValidationError2.default(`There are multiple rules for the following stage-order combinations
      ${(0, _utils.dumpJSON)(formatted)}.
       Only one rule must be defined for the same order number in a stage.`);
    }

    const existing = await this.getType();
    const stateChanged = futureRules.reduce((changed, rule) => [...changed, ...existing.filter(r => rule.name.toLowerCase() === r.name.toLowerCase() && r.stage !== rule.stage)], []).map(r => r.name);

    if (stateChanged.length > 0) {
      throw new _ValidationError2.default(`The following rules changed stage which is not allowed:
      ${(0, _utils.dumpJSON)(stateChanged)}.
      Rename the rules to recreate them and avoid this error.`);
    }

    await super.validate(assets);
  }

  async processChanges(assets) {
    const {
      rules
    } = assets;
    if (!rules) return;
    const changes = await this.calcChanges(assets);
    await this.client.pool.addEachTask({
      data: changes.reOrder,
      generator: rule => this.client.updateRule({
        id: rule.id
      }, (0, _utils.stripFields)(rule, this.stripUpdateFields)).then(() => {
        const updated = {
          name: rule.name,
          stage: rule.stage,
          order: rule.order,
          id: rule.id
        };

        _logger2.default.info(`Temporally re-order Rule ${(0, _utils.dumpJSON)(updated)}`);
      })
    }).promise();
    await super.processChanges(assets, {
      del: changes.del,
      create: changes.create,
      update: changes.update,
      conflicts: changes.conflicts
    });
  }

}

exports.default = RulesHandler;