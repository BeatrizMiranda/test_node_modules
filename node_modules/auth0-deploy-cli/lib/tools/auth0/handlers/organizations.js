"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.schema = undefined;

var _dec, _class;

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

var _default = require("./default");

var _default2 = _interopRequireDefault(_default);

var _utils = require("../../utils");

var _logger = require("../../logger");

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

const schema = exports.schema = {
  type: 'array',
  items: {
    type: 'object',
    properties: {
      name: {
        type: 'string'
      },
      display_name: {
        type: 'string'
      },
      branding: {
        type: 'object'
      },
      metadata: {
        type: 'object'
      },
      connections: {
        type: 'array',
        items: {
          type: 'object',
          properties: {
            connection_id: {
              type: 'string'
            },
            assign_membership_on_login: {
              type: 'boolean'
            }
          }
        }
      }
    },
    required: ['name']
  }
};
let OrganizationsHandler = (_dec = (0, _default.order)('70'), (_class = class OrganizationsHandler extends _default2.default {
  constructor(config) {
    super({ ...config,
      type: 'organizations',
      id: 'id',
      identifiers: ['name']
    });
  }

  async deleteOrganization(org) {
    await this.client.organizations.delete({
      id: org.id
    });
  }

  async deleteOrganizations(data) {
    if (this.config('AUTH0_ALLOW_DELETE') === 'true' || this.config('AUTH0_ALLOW_DELETE') === true) {
      await this.client.pool.addEachTask({
        data: data || [],
        generator: item => this.deleteOrganization(item).then(() => {
          this.didDelete(item);
          this.deleted += 1;
        }).catch(err => {
          throw new Error(`Problem deleting ${this.type} ${this.objString(item)}\n${err}`);
        })
      }).promise();
    } else {
      _logger2.default.warn(`Detected the following organizations should be deleted. Doing so may be destructive.\nYou can enable deletes by setting 'AUTH0_ALLOW_DELETE' to true in the config
      \n${data.map(i => this.objString(i)).join('\n')}`);
    }
  }

  async createOrganization(org) {
    const organization = { ...org
    };
    delete organization.connections;
    const created = await this.client.organizations.create(organization);

    if (typeof org.connections !== 'undefined' && org.connections.length > 0) {
      await Promise.all(org.connections.map(conn => this.client.organizations.addEnabledConnection({
        id: created.id
      }, conn)));
    }

    return created;
  }

  async createOrganizations(creates) {
    await this.client.pool.addEachTask({
      data: creates || [],
      generator: item => this.createOrganization(item).then(data => {
        this.didCreate(data);
        this.created += 1;
      }).catch(err => {
        throw new Error(`Problem creating ${this.type} ${this.objString(item)}\n${err}`);
      })
    }).promise();
  }

  async updateOrganization(org, organizations) {
    const {
      connections: existingConnections
    } = await organizations.find(orgToUpdate => orgToUpdate.name === org.name);
    const params = {
      id: org.id
    };
    const {
      connections
    } = org;
    delete org.connections;
    delete org.name;
    delete org.id;
    await this.client.organizations.update(params, org);
    const connectionsToRemove = existingConnections.filter(c => !connections.find(x => x.connection_id === c.connection_id));
    const connectionsToAdd = connections.filter(c => !existingConnections.find(x => x.connection_id === c.connection_id));
    const connectionsToUpdate = connections.filter(c => existingConnections.find(x => x.connection_id === c.connection_id && x.assign_membership_on_login !== c.assign_membership_on_login));
    await Promise.all(connectionsToUpdate.map(conn => this.client.organizations.updateEnabledConnection({
      connection_id: conn.connection_id,
      ...params
    }, {
      assign_membership_on_login: conn.assign_membership_on_login
    }).catch(() => {
      throw new Error(`Problem updating Enabled Connection ${conn.connection_id} for organizations ${params.id}`);
    })));
    await Promise.all(connectionsToAdd.map(conn => this.client.organizations.addEnabledConnection(params, _lodash2.default.omit(conn, 'connection')).catch(() => {
      throw new Error(`Problem adding Enabled Connection ${conn.connection_id} for organizations ${params.id}`);
    })));
    await Promise.all(connectionsToRemove.map(conn => this.client.organizations.removeEnabledConnection({
      connection_id: conn.connection_id,
      ...params
    }).catch(() => {
      throw new Error(`Problem removing Enabled Connection ${conn.connection_id} for organizations ${params.id}`);
    })));
    return params;
  }

  async updateOrganizations(updates, orgs) {
    await this.client.pool.addEachTask({
      data: updates || [],
      generator: item => this.updateOrganization(item, orgs).then(data => {
        this.didUpdate(data);
        this.updated += 1;
      }).catch(err => {
        throw new Error(`Problem updating ${this.type} ${this.objString(item)}\n${err}`);
      })
    }).promise();
  }

  async getType() {
    if (this.existing) {
      return this.existing;
    }

    if (!this.client.organizations || typeof this.client.organizations.getAll !== 'function') {
      return [];
    }

    try {
      const organizations = await this.client.organizations.getAll({
        paginate: true,
        include_totals: true
      });

      for (let index = 0; index < organizations.length; index++) {
        const connections = await this.client.organizations.connections.get({
          id: organizations[index].id
        });
        organizations[index].connections = connections;
      }

      this.existing = organizations;
      return this.existing;
    } catch (err) {
      if (err.statusCode === 404 || err.statusCode === 501) {
        return [];
      }

      throw err;
    }
  }

  async processChanges(assets) {
    const {
      organizations
    } = assets;
    if (!organizations) return;
    const existing = await this.getType();
    const existingConnections = await this.client.connections.getAll({
      paginate: true,
      include_totals: true
    });
    organizations.forEach(org => {
      org.connections = (org.connections || []).map(connection => {
        const {
          name
        } = connection;
        delete connection.name;
        return { ...connection,
          connection_id: (existingConnections.find(c => c.name === name) || {}).id
        };
      }).filter(connection => !!connection.connection_id);
    });
    const changes = (0, _utils.calcChanges)(this, organizations, existing, ['id', 'name']);

    _logger2.default.debug(`Start processChanges for organizations [delete:${changes.del.length}] [update:${changes.update.length}], [create:${changes.create.length}]`);

    const myChanges = [{
      del: changes.del
    }, {
      create: changes.create
    }, {
      update: changes.update
    }];
    await Promise.all(myChanges.map(async change => {
      switch (true) {
        case change.del && change.del.length > 0:
          await this.deleteOrganizations(change.del);
          break;

        case change.create && change.create.length > 0:
          await this.createOrganizations(changes.create);
          break;

        case change.update && change.update.length > 0:
          await this.updateOrganizations(change.update, existing);
          break;

        default:
          break;
      }
    }));
  }

}, (_applyDecoratedDescriptor(_class.prototype, "processChanges", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, "processChanges"), _class.prototype)), _class));
exports.default = OrganizationsHandler;