"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.order = order;

var _ValidationError = require("../../ValidationError");

var _ValidationError2 = _interopRequireDefault(_ValidationError);

var _logger = require("../../logger");

var _logger2 = _interopRequireDefault(_logger);

var _utils = require("../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function order(value) {
  return function decorator(t, n, descriptor) {
    descriptor.value.order = value;
    return descriptor;
  };
}

class DefaultHandler {
  constructor(options) {
    this.config = options.config;
    this.type = options.type;
    this.id = options.id || 'id';
    this.client = options.client;
    this.existing = null;
    this.identifiers = options.identifiers || ['id', 'name'];
    this.objectFields = options.objectFields || [];
    this.stripUpdateFields = [...(options.stripUpdateFields || []), this.id];
    this.functions = {
      getAll: 'getAll',
      create: 'create',
      update: 'update',
      delete: 'delete',
      ...(options.functions || {})
    };
    this.updated = 0;
    this.created = 0;
    this.deleted = 0;
  }

  getClientFN(fn) {
    if (typeof fn === 'string') {
      const client = Reflect.get(this.client, this.type);
      return Reflect.get(client, fn).bind(client);
    }

    return fn;
  }

  didDelete(item) {
    _logger2.default.info(`Deleted [${this.type}]: ${this.objString(item)}`);
  }

  didCreate(item) {
    _logger2.default.info(`Created [${this.type}]: ${this.objString(item)}`);
  }

  didUpdate(item) {
    _logger2.default.info(`Updated [${this.type}]: ${this.objString(item)}`);
  }

  objString(item) {
    return (0, _utils.dumpJSON)(item);
  }

  async getType() {
    throw new Error(`Must implement getType for type ${this.type}`);
  }

  async load() {
    _logger2.default.info(`Retrieving ${this.type} data from Auth0`);

    this.existing = await this.getType();
    return {
      [this.type]: this.existing
    };
  }

  async calcChanges(assets) {
    const typeAssets = assets[this.type];
    if (!typeAssets) return {};
    const existing = await this.getType();
    return (0, _utils.calcChanges)(this, typeAssets, existing, this.identifiers, this.objectFields);
  }

  async validate(assets) {
    const typeAssets = assets[this.type];
    if (!Array.isArray(typeAssets)) return;
    const duplicateNames = (0, _utils.duplicateItems)(typeAssets, 'name');

    if (duplicateNames.length > 0) {
      const formatted = duplicateNames.map(dups => dups.map(d => `${d.name}`));
      throw new _ValidationError2.default(`There are multiple ${this.type} with the same name combinations
      ${(0, _utils.dumpJSON)(formatted)}.
       Names must be unique.`);
    }

    const duplicateIDs = (0, _utils.duplicateItems)(typeAssets, this.id);

    if (duplicateIDs.length > 0) {
      const formatted = duplicateIDs.map(dups => dups.map(d => `${d[this.id]}`));
      throw new _ValidationError2.default(`There are multiple ${this.type} for the following stage-order combinations
      ${(0, _utils.dumpJSON)(formatted)}.
       Only one rule must be defined for the same order number in a stage.`);
    }
  }

  async processChanges(assets, changes) {
    if (!changes) {
      changes = await this.calcChanges(assets);
    }

    const del = changes.del || [];
    const update = changes.update || [];
    const create = changes.create || [];
    const conflicts = changes.conflicts || [];

    _logger2.default.debug(`Start processChanges for ${this.type} [delete:${del.length}] [update:${update.length}], [create:${create.length}], [conflicts:${conflicts.length}]`);

    if (del.length > 0) {
      const allowDelete = this.config('AUTH0_ALLOW_DELETE') === 'true' || this.config('AUTH0_ALLOW_DELETE') === true;
      const byExtension = this.config('EXTENSION_SECRET') && (this.type === 'rules' || this.type === 'resourceServers');
      const shouldDelete = allowDelete || byExtension;

      if (!shouldDelete) {
        _logger2.default.warn(`Detected the following ${this.type} should be deleted. Doing so may be destructive.\nYou can enable deletes by setting 'AUTH0_ALLOW_DELETE' to true in the config
        \n${changes.del.map(i => this.objString(i)).join('\n')}
         `);
      } else {
        await this.client.pool.addEachTask({
          data: del || [],
          generator: delItem => {
            const delFunction = this.getClientFN(this.functions.delete);
            return delFunction({
              [this.id]: delItem[this.id]
            }).then(() => {
              this.didDelete(delItem);
              this.deleted += 1;
            }).catch(err => {
              throw new Error(`Problem deleting ${this.type} ${this.objString(delItem)}\n${err}`);
            });
          }
        }).promise();
      }
    }

    await this.client.pool.addEachTask({
      data: conflicts || [],
      generator: updateItem => {
        const updateFN = this.getClientFN(this.functions.update);
        const params = {
          [this.id]: updateItem[this.id]
        };
        const payload = (0, _utils.stripFields)({ ...updateItem
        }, this.stripUpdateFields);
        return updateFN(params, payload).then(data => this.didUpdate(data)).catch(err => {
          throw new Error(`Problem updating ${this.type} ${this.objString(updateItem)}\n${err}`);
        });
      }
    }).promise();
    await this.client.pool.addEachTask({
      data: create || [],
      generator: createItem => {
        const createFunction = this.getClientFN(this.functions.create);
        return createFunction(createItem).then(data => {
          this.didCreate(data);
          this.created += 1;
        }).catch(err => {
          throw new Error(`Problem creating ${this.type} ${this.objString(createItem)}\n${err}`);
        });
      }
    }).promise();
    await this.client.pool.addEachTask({
      data: update || [],
      generator: updateItem => {
        const updateFN = this.getClientFN(this.functions.update);
        const params = {
          [this.id]: updateItem[this.id]
        };
        const payload = (0, _utils.stripFields)({ ...updateItem
        }, this.stripUpdateFields);
        return updateFN(params, payload).then(data => {
          this.didUpdate(data);
          this.updated += 1;
        }).catch(err => {
          throw new Error(`Problem updating ${this.type} ${this.objString(updateItem)}\n${err}`);
        });
      }
    }).promise();
  }

}

exports.default = DefaultHandler;