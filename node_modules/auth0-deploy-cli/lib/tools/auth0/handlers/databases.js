"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.schema = undefined;

var _dec, _class;

var _default = require("./default");

var _default2 = _interopRequireDefault(_default);

var _constants = require("../../constants");

var _constants2 = _interopRequireDefault(_constants);

var _utils = require("../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

const schema = exports.schema = {
  type: 'array',
  items: {
    type: 'object',
    properties: {
      strategy: {
        type: 'string',
        enum: ['auth0'],
        default: 'auth0'
      },
      name: {
        type: 'string'
      },
      options: {
        type: 'object',
        properties: {
          customScripts: {
            type: 'object',
            properties: { ..._constants2.default.DATABASE_SCRIPTS.reduce((o, script) => ({ ...o,
                [script]: {
                  type: 'string'
                }
              }), {})
            }
          }
        }
      }
    },
    required: ['name']
  }
};
let DatabaseHandler = (_dec = (0, _default.order)('60'), (_class = class DatabaseHandler extends _default2.default {
  constructor(config) {
    super({ ...config,
      type: 'databases',
      stripUpdateFields: ['strategy', 'name']
    });
  }

  objString(db) {
    return super.objString({
      name: db.name,
      id: db.id
    });
  }

  getClientFN(fn) {
    if (fn === this.functions.update) {
      return (params, payload) => this.client.connections.get(params).then(connection => {
        payload.options = { ...connection.options,
          ...payload.options
        };
        return this.client.connections.update(params, payload);
      });
    }

    return Reflect.get(this.client.connections, fn, this.client.connections);
  }

  async getType() {
    if (this.existing) return this.existing;
    this.existing = this.client.connections.getAll({
      strategy: 'auth0',
      paginate: true,
      include_totals: true
    });
    return this.existing;
  }

  async calcChanges(assets) {
    const {
      databases
    } = assets;
    if (!databases) return {};
    const clients = await this.client.clients.getAll({
      paginate: true,
      include_totals: true
    });
    const existingDatabasesConecctions = await this.client.connections.getAll({
      strategy: 'auth0',
      paginate: true,
      include_totals: true
    });
    const formatted = databases.map(db => {
      if (db.enabled_clients) {
        return { ...db,
          enabled_clients: (0, _utils.getEnabledClients)(assets, db, existingDatabasesConecctions, clients)
        };
      }

      return db;
    });
    return super.calcChanges({ ...assets,
      databases: formatted
    });
  }

  async processChanges(assets) {
    const {
      databases
    } = assets;
    if (!databases) return;
    const excludedConnections = assets.exclude && assets.exclude.databases || [];
    const changes = await this.calcChanges(assets);
    await super.processChanges(assets, (0, _utils.filterExcluded)(changes, excludedConnections));
  }

}, (_applyDecoratedDescriptor(_class.prototype, "processChanges", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, "processChanges"), _class.prototype)), _class));
exports.default = DatabaseHandler;