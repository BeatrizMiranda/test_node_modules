"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.schema = undefined;

var _dec, _class;

var _default = require("./default");

var _default2 = _interopRequireDefault(_default);

var _utils = require("../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _applyDecoratedDescriptor(target, property, decorators, descriptor, context) { var desc = {}; Object.keys(descriptor).forEach(function (key) { desc[key] = descriptor[key]; }); desc.enumerable = !!desc.enumerable; desc.configurable = !!desc.configurable; if ('value' in desc || desc.initializer) { desc.writable = true; } desc = decorators.slice().reverse().reduce(function (desc, decorator) { return decorator(target, property, desc) || desc; }, desc); if (context && desc.initializer !== void 0) { desc.value = desc.initializer ? desc.initializer.call(context) : void 0; desc.initializer = undefined; } if (desc.initializer === void 0) { Object.defineProperty(target, property, desc); desc = null; } return desc; }

const schema = exports.schema = {
  type: 'array',
  items: {
    type: 'object',
    properties: {
      name: {
        type: 'string'
      },
      strategy: {
        type: 'string'
      },
      options: {
        type: 'object'
      },
      enabled_clients: {
        type: 'array',
        items: {
          type: 'string'
        }
      },
      realms: {
        type: 'array',
        items: {
          type: 'string'
        }
      },
      metadata: {
        type: 'object'
      }
    },
    required: ['name', 'strategy']
  }
};
let ConnectionsHandler = (_dec = (0, _default.order)('60'), (_class = class ConnectionsHandler extends _default2.default {
  constructor(config) {
    super({ ...config,
      type: 'connections',
      stripUpdateFields: ['strategy', 'name']
    });
  }

  objString(connection) {
    return super.objString({
      name: connection.name,
      id: connection.id
    });
  }

  getFormattedOptions(connection, clients) {
    try {
      return {
        options: { ...connection.options,
          idpinitiated: { ...connection.options.idpinitiated,
            client_id: (0, _utils.convertClientNameToId)(connection.options.idpinitiated.client_id, clients)
          }
        }
      };
    } catch (e) {
      return {};
    }
  }

  async getType() {
    if (this.existing) return this.existing;
    const connections = await this.client.connections.getAll({
      paginate: true,
      include_totals: true
    });
    this.existing = connections.filter(c => c.strategy !== 'auth0');
    return this.existing;
  }

  async calcChanges(assets) {
    const {
      connections
    } = assets;
    if (!connections) return {};
    const clients = await this.client.clients.getAll({
      paginate: true,
      include_totals: true
    });
    const existingConnections = await this.client.connections.getAll({
      paginate: true,
      include_totals: true
    });
    const formatted = assets.connections.map(connection => ({ ...connection,
      ...this.getFormattedOptions(connection, clients),
      enabled_clients: (0, _utils.getEnabledClients)(assets, connection, existingConnections, clients)
    }));
    return super.calcChanges({ ...assets,
      connections: formatted
    });
  }

  async processChanges(assets) {
    const {
      connections
    } = assets;
    if (!connections) return;
    const excludedConnections = assets.exclude && assets.exclude.connections || [];
    const changes = await this.calcChanges(assets);
    await super.processChanges(assets, (0, _utils.filterExcluded)(changes, excludedConnections));
  }

}, (_applyDecoratedDescriptor(_class.prototype, "processChanges", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, "processChanges"), _class.prototype)), _class));
exports.default = ConnectionsHandler;